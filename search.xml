<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2022-10-31-每日一题-恢复二叉树</title>
      <link href="/2023/03/05/2022-10-31-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/03/05/2022-10-31-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a><a href="https://leetcode.cn/problems/recover-binary-search-tree/description/">恢复二叉搜索树</a></h1><p>给你二叉搜索树的根节点 <code>root</code> ，该树中的 <strong>恰好</strong> 两个节点的值被错误地交换。<em>请在不改变其结构的情况下，恢复这棵树</em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,3,null,null,2]</span><br><span class="line">输出：[3,1,null,null,2]</span><br><span class="line">解释：3 不能是 1 的左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,1,4,null,null,2]</span><br><span class="line">输出：[2,1,4,null,null,3]</span><br><span class="line">解释：2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树上节点的数目在范围 <code>[2, 1000]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><p><strong>进阶：</strong>使用 <code>O(n)</code> 空间复杂度的解法很容易实现。你能想出一个只使用 <code>O(1)</code> 空间的解决方案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeNode *wrongA = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode *wrongB = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// find and swap</span></span><br><span class="line">        stack&lt;TreeNode *&gt; st;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() || p != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Inorder is the true list of the value</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            p = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;val &gt; p-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (wrongA == <span class="literal">nullptr</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    wrongA = pre;</span><br><span class="line">                    wrongB = p; <span class="comment">// swap ,which steps I missed</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    wrongB = p;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = p; <span class="comment">// When the Node is used, we can mark it as Pre.</span></span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(wrongA-&gt;val, wrongB-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用O(1)的空间。交换一次使得序列变得有序</span><br><span class="line">pre指向前一个节点。</span><br><span class="line">wrongA是pre和p的val不一样时候的pre，后面的前面跑到前面来，使得p的值会小于pre</span><br><span class="line">wrongB是pre和p的val不一样时候的p,前面的节点跑到前面来，使得p的值会小于pre</span><br><span class="line">但是也有可能wrongA和wrongB相邻，所以第一次的时候就把wrongB设好</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2022-10-31- 每日一题-二叉树的层次遍历</title>
      <link href="/2023/03/05/2022-10-31-%20%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
      <url>/2023/03/05/2022-10-31-%20%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">二叉树的层序遍历</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Medium (65.14%)</td><td align="center">1495</td><td align="center">-</td></tr></tbody></table><details style="color: rgb(238, 255, 255); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Tags</strong></summary><p style="margin-top: 0px; margin-bottom: 0.7em;"><a href="https://leetcode.com/tag/tree" title="https://leetcode.com/tag/tree" style="color: var(--vscode-textLink-foreground); text-decoration: none;"><code style="color: var(--vscode-textLink-foreground); font-family: var(--vscode-editor-font-family, &quot;SF Mono&quot;, Monaco, Menlo, Consolas, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Courier New&quot;, monospace); font-size: 1em; line-height: 1.357em; white-space: pre-wrap;"></code></a><a href="https://leetcode.com/tag/breadth-first-search" title="https://leetcode.com/tag/breadth-first-search" style="color: var(--vscode-textLink-foreground); text-decoration: none;"><code style="color: var(--vscode-textLink-foreground); font-family: var(--vscode-editor-font-family, &quot;SF Mono&quot;, Monaco, Menlo, Consolas, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Courier New&quot;, monospace); font-size: 1em; line-height: 1.357em; white-space: pre-wrap;"></code></a></p></details><details style="color: rgb(238, 255, 255); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Companies</strong></summary><p style="margin-top: 0px; margin-bottom: 0.7em;"><code style="color: var(--vscode-textPreformat-foreground); font-family: var(--vscode-editor-font-family, &quot;SF Mono&quot;, Monaco, Menlo, Consolas, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Courier New&quot;, monospace); font-size: 1em; line-height: 1.357em; white-space: pre-wrap;"></code><code style="color: var(--vscode-textPreformat-foreground); font-family: var(--vscode-editor-font-family, &quot;SF Mono&quot;, Monaco, Menlo, Consolas, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Courier New&quot;, monospace); font-size: 1em; line-height: 1.357em; white-space: pre-wrap;"></code><code style="color: var(--vscode-textPreformat-foreground); font-family: var(--vscode-editor-font-family, &quot;SF Mono&quot;, Monaco, Menlo, Consolas, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Courier New&quot;, monospace); font-size: 1em; line-height: 1.357em; white-space: pre-wrap;"></code><code style="color: var(--vscode-textPreformat-foreground); font-family: var(--vscode-editor-font-family, &quot;SF Mono&quot;, Monaco, Menlo, Consolas, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Courier New&quot;, monospace); font-size: 1em; line-height: 1.357em; white-space: pre-wrap;"></code><code style="color: var(--vscode-textPreformat-foreground); font-family: var(--vscode-editor-font-family, &quot;SF Mono&quot;, Monaco, Menlo, Consolas, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Courier New&quot;, monospace); font-size: 1em; line-height: 1.357em; white-space: pre-wrap;"></code><code style="color: var(--vscode-textPreformat-foreground); font-family: var(--vscode-editor-font-family, &quot;SF Mono&quot;, Monaco, Menlo, Consolas, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Courier New&quot;, monospace); font-size: 1em; line-height: 1.357em; white-space: pre-wrap;"></code></p></details><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 2000]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode *root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// BFS队列</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        deque&lt;TreeNode *&gt; q;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push_back</span>(root); <span class="comment">// init</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="comment">// process a depth</span></span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode *p = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">                ans.<span class="built_in">back</span>().<span class="built_in">push_back</span>(p-&gt;val); <span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left != <span class="literal">nullptr</span>)       <span class="comment">// next depth&#x27;s node will be added to the deque.</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push_back</span>(p-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right != <span class="literal">nullptr</span>) <span class="comment">// next depth&#x27;s node will be added to the deque.</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push_back</span>(p-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面是源代码</span><br></pre></td></tr></table></figure><p><img src="http://pic.mikumifa.cn/2022/10/31/e8cabb08002da.jpg" alt="123"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2022-10-31-每日一题-中序和前序组成二叉树</title>
      <link href="/2023/03/05/2022-10-31-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%89%8D%E5%BA%8F%E7%BB%84%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2023/03/05/2022-10-31-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%89%8D%E5%BA%8F%E7%BB%84%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">从前序与中序遍历序列构造二叉树</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Medium (71.37%)</td><td align="center">1777</td><td align="center">-</td></tr></tbody></table><details style="color: rgb(238, 255, 255); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Tags</strong></summary><p style="margin-top: 0px; margin-bottom: 0.7em;"><a href="https://leetcode.com/tag/array" title="https://leetcode.com/tag/array" style="color: var(--vscode-textLink-foreground); text-decoration: none;"><code style="color: var(--vscode-textLink-foreground); font-family: var(--vscode-editor-font-family, &quot;SF Mono&quot;, Monaco, Menlo, Consolas, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Courier New&quot;, monospace); font-size: 1em; line-height: 1.357em; white-space: pre-wrap;"></code></a><a href="https://leetcode.com/tag/tree" title="https://leetcode.com/tag/tree" style="color: var(--vscode-textLink-foreground); text-decoration: none;"><code style="color: var(--vscode-textLink-foreground); font-family: var(--vscode-editor-font-family, &quot;SF Mono&quot;, Monaco, Menlo, Consolas, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Courier New&quot;, monospace); font-size: 1em; line-height: 1.357em; white-space: pre-wrap;"></code></a><a href="https://leetcode.com/tag/depth-first-search" title="https://leetcode.com/tag/depth-first-search" style="color: var(--vscode-textLink-foreground); text-decoration: none;"><code style="color: var(--vscode-textLink-foreground); font-family: var(--vscode-editor-font-family, &quot;SF Mono&quot;, Monaco, Menlo, Consolas, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Courier New&quot;, monospace); font-size: 1em; line-height: 1.357em; white-space: pre-wrap;"></code></a></p></details><details style="color: rgb(238, 255, 255); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Companies</strong></summary><p style="margin-top: 0px; margin-bottom: 0.7em;"><code style="color: var(--vscode-textPreformat-foreground); font-family: var(--vscode-editor-font-family, &quot;SF Mono&quot;, Monaco, Menlo, Consolas, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Courier New&quot;, monospace); font-size: 1em; line-height: 1.357em; white-space: pre-wrap;"></code></p></details><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">输出: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = [-1], inorder = [-1]</span><br><span class="line">输出: [-1]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li><li><code>inorder</code> 均出现在 <code>preorder</code></li><li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li><li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;preorder, vector&lt;<span class="type">int</span>&gt; &amp;inorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/*The first element in preorder array can divide inorder array into two parts.</span></span><br><span class="line"><span class="comment">        Then we can divide preorder array into two parts. Make this element a node.</span></span><br><span class="line"><span class="comment">        And the left sub-tree of this node is the left part,</span></span><br><span class="line"><span class="comment">        right sub-tree of this node is the right part.</span></span><br><span class="line"><span class="comment">        This problem can be solved following this logic.*/</span></span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> rootValue = preorder[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> rootIndex = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == rootValue)</span><br><span class="line">            &#123;</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *head = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; n1 = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(preorder.<span class="built_in">begin</span>() + <span class="number">1</span>, preorder.<span class="built_in">begin</span>() + rootIndex + <span class="number">1</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; n2 = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(inorder.<span class="built_in">begin</span>(), inorder.<span class="built_in">begin</span>() + rootIndex);</span><br><span class="line">        head-&gt;left = <span class="built_in">buildTree</span>(n1, n2);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; n3 = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(preorder.<span class="built_in">begin</span>() + rootIndex + <span class="number">1</span>, preorder.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; n4 = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(inorder.<span class="built_in">begin</span>() + rootIndex + <span class="number">1</span>, inorder.<span class="built_in">end</span>());</span><br><span class="line">        head-&gt;right = <span class="built_in">buildTree</span>(n3, n4);</span><br><span class="line">        <span class="comment">/*the way of using vector and initialization*/</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector初始化，注意下表，和为0的边界情况</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2022-11-1-每日一题-二叉树展开为链表</title>
      <link href="/2023/03/05/2022-11-1-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/03/05/2022-11-1-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/">二叉树展开为链表</a></h1><details style="color: rgb(238, 255, 255); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Tags</strong></summary><p style="margin-top: 0px; margin-bottom: 0.7em;"><a href="https://leetcode.com/tag/tree" title="https://leetcode.com/tag/tree" style="color: var(--vscode-textLink-foreground); text-decoration: none;"><code style="color: var(--vscode-textLink-foreground); font-family: var(--vscode-editor-font-family, &quot;SF Mono&quot;, Monaco, Menlo, Consolas, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Courier New&quot;, monospace); font-size: 1em; line-height: 1.357em; white-space: pre-wrap;"></code></a><a href="https://leetcode.com/tag/depth-first-search" title="https://leetcode.com/tag/depth-first-search" style="color: var(--vscode-textLink-foreground); text-decoration: none;"><code style="color: var(--vscode-textLink-foreground); font-family: var(--vscode-editor-font-family, &quot;SF Mono&quot;, Monaco, Menlo, Consolas, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Courier New&quot;, monospace); font-size: 1em; line-height: 1.357em; white-space: pre-wrap;"></code></a></p></details><details style="color: rgb(238, 255, 255); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Companies</strong></summary><p style="margin-top: 0px; margin-bottom: 0.7em;"><code style="color: var(--vscode-textPreformat-foreground); font-family: var(--vscode-editor-font-family, &quot;SF Mono&quot;, Monaco, Menlo, Consolas, &quot;Ubuntu Mono&quot;, &quot;Liberation Mono&quot;, &quot;DejaVu Sans Mono&quot;, &quot;Courier New&quot;, monospace); font-size: 1em; line-height: 1.357em; white-space: pre-wrap;"></code></p></details><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,5,3,4,null,6]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">preorder</span>(root);</span><br><span class="line">        <span class="type">int</span> len = ans.<span class="built_in">size</span>();</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(ans[i], <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;val = root-&gt;right-&gt;val;</span><br><span class="line">        root-&gt;right = root-&gt;right-&gt;right;</span><br><span class="line">        root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">preorder</span>(root-&gt;left);</span><br><span class="line">            <span class="built_in">preorder</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DFS太简单了，注意改变root的值是没用的要改变他所指向的地址的值才可以。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++补充-1</title>
      <link href="/2023/03/05/c++%E8%A1%A5%E5%85%85-1/"/>
      <url>/2023/03/05/c++%E8%A1%A5%E5%85%85-1/</url>
      
        <content type="html"><![CDATA[<h1 id="C-隐秘规则的补充"><a href="#C-隐秘规则的补充" class="headerlink" title="C++隐秘规则的补充"></a>C++隐秘规则的补充</h1><h2 id="C-amp-和-amp-amp-的用法"><a href="#C-amp-和-amp-amp-的用法" class="headerlink" title="C++&amp;和&amp;&amp;的用法"></a>C++&amp;和&amp;&amp;的用法</h2><h6 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string *p=&amp;s;//取地址</span><br><span class="line">int &amp;p=a;//引用</span><br><span class="line">int* &amp;p=&amp;a;//指针的引用</span><br><span class="line">void swap(int &amp;a,int &amp;b);//形参的改变会改变实参</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void func(int(&amp;a)[5]);//数组引用作为函数的参数，必须指明数组的长度</span><br></pre></td></tr></table></figure><h6 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void func2(const string &amp;str);//str不可以改变</span><br><span class="line">//常引用和常指针一样，所指的值无法改变</span><br></pre></td></tr></table></figure><h6 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h6><p>左值：lvalue-&gt;loactor value储存在内存中，有明确存储地址的数据</p><p>右值：rvalue-&gt;reed value不一定可以寻址，例如存储于寄存器中的数据，例如说表达式的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//左值引用</span><br><span class="line">int num = 10;</span><br><span class="line">int &amp;b = num;     // 正确</span><br><span class="line">int &amp;c = 10;      // 错误</span><br><span class="line">// 右值引用</span><br><span class="line">int num = 10;</span><br><span class="line">//int &amp;&amp; a = num;    // 错误，右值引用不能初始化为左值</span><br><span class="line">int &amp;&amp; a = 10;       // 正确</span><br></pre></td></tr></table></figure><h6 id="右值引用可以用来move-constructer"><a href="#右值引用可以用来move-constructer" class="headerlink" title="右值引用可以用来move constructer"></a>右值引用可以用来move constructer</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">User::User(User&amp;&amp;p)&#123;</span><br><span class="line">this-&gt;p=p;//this-&gt;p指向了p的p,</span><br><span class="line">p=nullptr;//为了防止p被重复析构，原来的p设为nullptr.</span><br><span class="line">对空指针使用nullptr是可以的。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说白了，就是用右值引用引用一个值，然后把里面的指针给转移到现有的上面。</p><h2 id="逗号表达式"><a href="#逗号表达式" class="headerlink" title="逗号表达式"></a>逗号表达式</h2><p>逗号表达式的值是最后一个的值</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new 一个</span></span><br><span class="line"><span class="type">int</span> **p=<span class="keyword">new</span> <span class="type">int</span>*[<span class="number">10</span>];<span class="comment">//先new一个有10个元素的指针数组，*是在类型的后面，变量的前面。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">  p[i] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二维数组可以降纬操作，想象空间是一排连一起的</span></span><br></pre></td></tr></table></figure><h2 id="Struct的对齐操作"><a href="#Struct的对齐操作" class="headerlink" title="Struct的对齐操作"></a>Struct的对齐操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、第一个成员的首地址为<span class="number">0.</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、每个成员的首地址是自身大小的整数倍</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、结构体的总大小，为其成员中所含最大类型的整数倍</span><br><span class="line"><span class="comment">//宏声明的和实际数据类型中最大值较小（如果有宏声明）</span></span><br><span class="line"><span class="comment">//内存对齐主要是为了提高访问的效率</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(n)<span class="comment">//这个是宏定义</span></span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数编译链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编译的时候只编译当前的模块，只有到链接的时候，a.obj才会从b.obj中获得f()函数的信息(这就是为什么要预先)，</span><br><span class="line">链接的时候主要是为了确定各部分的地址，将编译记过中的地址符号全部换成实地址。</span><br></pre></td></tr></table></figure><p>函数的默认参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">必须从右向左</span><br></pre></td></tr></table></figure><p>函数重载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不允许参数的个数，类型，顺序完全相同</span><br><span class="line">//函数不能既为重载函数，又为有默认参数函数。</span><br><span class="line">当未传入参数时，系统无法判定调用哪一个参数。</span><br></pre></td></tr></table></figure><p>符号表机制（编译的时候产生）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*与编译的各个阶段都有交互，存有函数名、地址等信息；编译时会创建一个函数符号表&lt;name,address&gt;，对应的符号后面的地址还没确定(link期决定)，call name根据name找到符号表对应的地址，再执行。</span></span><br><span class="line"><span class="comment">对于c语言来说，编译得到的符号表内函数f在符号表里的name就是f(不存在函数重载)*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">f</span><span class="params">()</span>;<span class="comment">//这个是c的函数，使用extern</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">()</span>&#123;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的内存<img src="http://pic.mikumifa.cn/2022/11/02/42b8e005e0110.png"></p><ol><li>从上往下分别是<ul><li>code:每个指令都有对应的单元地址。函数的代码存放的位置是受到限制的</li><li>Data:存放数据(局部变量和全局变量)</li><li>Stack:由系统管理，存放函数</li><li>Heap:可以用程序员进行分配，可以在运行时动态确定，<code>int *p = (int *)malloc(4)</code>，归还内存<code>free</code>(在C++中不推荐使用这种方法进行处理，而是使用new和delete)</li></ul></li></ol><h2 id="RunTime-Environment"><a href="#RunTime-Environment" class="headerlink" title="RunTime Environment"></a>RunTime Environment</h2><p>_cdecl，函数空间(参数)归<strong>调用者</strong>管理，本章讲解的是这种，也就是被调用者不清空栈，调用者清空栈。</p><p>问题:函数调用者结束后，原空间的参数仍然在(未归还)</p><p>好处:由调用者管理所有的调用参数，可以灵活管理参数。</p><p>坏处:安全问题，调用者环境被破坏</p><p>_stdcal函数调用后，函数空间由被调用者管理，被调用者清空栈。</p><p>调用者来传递参数(申请空间)，由被调用者归还参数(归还空间)，这部分空间被称为<strong>中间地带</strong>。caller:调用者，callee:被调用者</p><p>好处:空间节省，跨平台性。</p><p>坏处:对于可变参数的函数无法计算ebp的参数个数，但是对于调用者是知道的，这样只能使用_cdecl</p><h2 id="栈空间"><a href="#栈空间" class="headerlink" title="栈空间"></a>栈空间</h2><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-C-plus-plus-advanced-programming/img/function/1.png" alt="img"></p><ul><li><p>栈空间是从高地址向低地址生长</p></li><li><p>栈底:ebp(当前函数的存取指针，即存储或者读取数时的指针基地址)</p></li><li><p>栈顶:esp(当前函数的栈顶指针)</p></li><li><p>保存:返回地址、调用者的基指针</p></li><li><p>过程描述:调用一个函数时，先将堆栈原先的基址(ebp)入栈，以保存之前任务的信息。然后将栈顶指针的值赋给ebp，<strong>将之前的栈顶作为新的基址</strong>(栈底)，然后<strong>在这个基址上开辟相应的空间用作被调用函数的堆栈</strong>。函数返回后，<strong>从ebp中可取出之前的esp值，使栈顶恢复函数调用前的位置</strong>；再从恢复后的栈顶可弹出之前的EBP值，因为这个值在函数调用前一步被压入堆栈。这样，EBP和ESP就都恢复了调用前的位置，堆栈恢复函数调用前的状态。</p></li><li><pre><code>开始调用esp从栈顶向下移动32位，存ret_addr，开辟main函数的栈空间然后esp继续向下存esp_main然后ebp到esp处然后esp到新的函数空间的栈顶函数处理esp先返回到ebp然后ebp根据esp_main返回，然后esp加一(向上)之后esp回到ret_addr位置即可。</code></pre><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2></li></ul><p>目的:</p><ol><li><p>提高可读性</p></li><li><p>提高效率</p><p>编译系统将为 inline 函数创建一段代码，在调用点，以相应的代码替换</p></li></ol><p>限制：必须是非递归的函数，由编译系统控制，和编译器相关，inline是请求，不一定是内联函数。</p><p>缺点：</p><p>增加代码量，换页可能会导致操作系统的抖动，降低cache的命中率</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>指令集结构</title>
      <link href="/2023/03/05/%E6%8C%87%E4%BB%A4%E9%9B%86%E7%BB%93%E6%9E%84/"/>
      <url>/2023/03/05/%E6%8C%87%E4%BB%A4%E9%9B%86%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="指令集结构"><a href="#指令集结构" class="headerlink" title="指令集结构"></a>指令集结构</h2><h3 id="DLX简述"><a href="#DLX简述" class="headerlink" title="DLX简述"></a>DLX简述</h3><ul><li><p>MIPS指令集简化，有2^32个单元的地址空间，</p><ul><li><p>地址表示法32位，4字节，8位16进制数</p></li><li><p>寻址能力8位，字节寻址</p></li></ul></li><li><p>每一个存储单元的数据位数是8位</p><ul><li><p>ASCII码只需要一个存储单元</p></li><li><p>访问字只需要起始地址</p></li><li><p>起始地址必须是4的倍数，边界对齐</p></li></ul></li><li><p>采用大端法，</p></li><li><p>有32个通用寄存器，使用5位编码来标识寄存器，被标记为R0，R1，R2，R3，R4。。。。。。。。。R0寄存器必须是0</p></li><li><p>有32个浮点寄存器，用于单精度和双精度计算（DLX有32个浮点寄存器和32个通用寄存器）</p></li><li><p>指令（操作码，和操作数）</p></li></ul><p><img src="https://pic.mikumifa.cn/2022/11/02/fd448bf566a2f.png"></p><p>DLX共有91条指令</p><ul><li><p>DLX的寻址模式，只有基址+偏移量</p></li><li><p>DLX的数据类型，整数包括8,16,32位，浮点数32位单精度和64位双精度。</p></li></ul><h2 id="算术-x2F-逻辑运算指令"><a href="#算术-x2F-逻辑运算指令" class="headerlink" title="算术&#x2F;逻辑运算指令"></a>算术&#x2F;逻辑运算指令</h2><p>I型imm16立即数符号扩展。SR1和DR是寄存器的标号，DR是目的操作数，（但是DR和SR1可以相同，一个寄存器可以作为源操作数，也可以作为目的操作数）</p><p><img src="https://pic.mikumifa.cn/2022/11/02/cd6a87eaa5525.png"></p><p><img src="https://pic.mikumifa.cn/2022/11/02/efb9f9420d01c.png"></p><p><img src="https://pic.mikumifa.cn/2022/11/02/e75f6f395bf04.png"></p><p><img src="https://pic.mikumifa.cn/2022/11/02/a9d9feb04f78e.png"></p><p><img src="https://pic.mikumifa.cn/2022/11/02/af9b8d8a4f259.png"></p><p><img src="https://pic.mikumifa.cn/2022/11/02/a5e534abf319f.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLEI和SLTI，一个是小于等于，一个是小于，是第一个源寄存器和imm来比较，目的寄存器会被置0或置1</span><br></pre></td></tr></table></figure><p><img src="https://pic.mikumifa.cn/2022/11/02/38669043f5148.png"></p><p><img src="https://pic.mikumifa.cn/2022/11/02/4022d903a639e.png"></p><p><img src="/https://pic.mikumifa.cn/2022/11/02/6814f14f91c80.png" alt="image-20221102170120739"></p><p><img src="https://pic.mikumifa.cn/2022/11/02/6a6c92eac971d.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LHI比较特别，左移动16位之后赋值（准确来说是加法）到一个寄存器上面，主要是为了把大的常数赋值到寄存器上面</span><br></pre></td></tr></table></figure><h4 id="R型运算指令。"><a href="#R型运算指令。" class="headerlink" title="R型运算指令。"></a>R型运算指令。</h4><p>操作数是000000，什么操作主要看函数，有2个源操作数，1个目的操作数</p><p>处理LHI之外都有其他指令，解释类似</p><h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><p>加载：将数据从存储器移动到寄存器的过程</p><p>存储：将数据从寄存器移动到存储器的过程</p><p>LB和SB 字节</p><p>LW和SW是加载和存储字（32位，4字节）&#x2F;&#x2F;和gun汇编语言差不多</p><h3 id="基址寄存器-偏移量"><a href="#基址寄存器-偏移量" class="headerlink" title="基址寄存器+偏移量"></a>基址寄存器+偏移量</h3><p>将16位的偏移量进行符号扩展后，和一个基址寄存器相加</p><p>对于SW，LW基址寄存器+偏移量必须是4的倍数（边界对齐）</p><p>pc-pc+4（一条指令4个字节）</p><h2 id="控制指令"><a href="#控制指令" class="headerlink" title="控制指令"></a>控制指令</h2><ul><li>条件分支</li><li>无条件跳转</li><li>子例程调用</li><li>TRAP</li><li>从异常&#x2F;中断返回</li></ul><h3 id="BEQZ"><a href="#BEQZ" class="headerlink" title="BEQZ"></a>BEQZ</h3><p>立即数是跳转的量，SR1用来判断</p><p><img src="https://pic.mikumifa.cn/2022/11/02/bdae571937265.png"></p><p>注意pc+4已经完成。</p><p><img src="https://pic.mikumifa.cn/2022/11/02/ff659216889dd.png"></p><p>地址限制</p><ol><li>加上imm的偏移量之前PC已经加4</li><li>所以范围<img src="https://pic.mikumifa.cn/2022/11/02/537a0ec78eb2d.png"></li></ol><p><img src="https://pic.mikumifa.cn/2022/11/02/c5f1f1e2ee0f5.png"></p><p>无条件的跳转指令</p><h3 id="JR指令，直接从寄存器里面找地址"><a href="#JR指令，直接从寄存器里面找地址" class="headerlink" title="JR指令，直接从寄存器里面找地址"></a>JR指令，直接从寄存器里面找地址</h3><p>I型<img src="https://pic.mikumifa.cn/2022/11/02/01820c6cf449d.png"></p><h3 id="J型指令，，超长的立即数"><a href="#J型指令，，超长的立即数" class="headerlink" title="J型指令，，超长的立即数"></a>J型指令，，超长的立即数</h3><p><img src="https://pic.mikumifa.cn/2022/11/02/4adb788cc1671.png"></p><p><img src="https://pic.mikumifa.cn/2022/11/02/cb7080d1b1a76.png"></p><h3 id="TRAP指令"><a href="#TRAP指令" class="headerlink" title="TRAP指令"></a>TRAP指令</h3><p>操作码110000，[25:0]是TRAP向量，标明程序希望操作系统执行哪一个服务调用</p><p><img src="https://pic.mikumifa.cn/2022/11/02/1024e8e5e3a49.png"></p><p><img src="https://pic.mikumifa.cn/2022/11/02/bb1076934fa83.png"></p><p>汇编语言的目的是靠近操作码的，但是在物理储存上不是这样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">LHI R1 x3000 #R1初始化为x3000</span><br><span class="line"></span><br><span class="line">ANDI R3 R3 $0 #R3初始化为0（ 区分ANDI和ADDI）</span><br><span class="line"></span><br><span class="line">ADDI R2 R0 $10 #R2初始化为10</span><br><span class="line"></span><br><span class="line">BEQZ R2 x14 # 看一下R2是否为0，如果R2为0了，直接跳出程序</span><br><span class="line"></span><br><span class="line">不为0就继续超下面执行</span><br><span class="line"></span><br><span class="line">LW R4 0（R1） #从储存器里面加载数据，保存到R4里面</span><br><span class="line"></span><br><span class="line">ADD R3 R3 R4 #R4的值加到R3里面</span><br><span class="line"></span><br><span class="line">ADDI R1 R1 #4 #R1的值加4（下边读取的地址加4）</span><br><span class="line"></span><br><span class="line">SUBI R2 R2 #1, #R1的值减1</span><br><span class="line"></span><br><span class="line">J #-24往后跳5个智力，也就是判断那里</span><br></pre></td></tr></table></figure><h2 id="DLX的指令的处理"><a href="#DLX的指令的处理" class="headerlink" title="DLX的指令的处理"></a>DLX的指令的处理</h2><p><img src="https://pic.mikumifa.cn/2022/11/02/b012536e34eec.png"></p><p>IR指令寄存器，PC程序计数器，MDR数据寄存器，MAR地址寄存器</p><p>实心是数据元素，空心是数据处理的控制信号，有限状态机的所有输出都是空心剪头。</p><p>AMUX选择的是PC和寄存器SR1内数据，</p><p>BMUX是4和立即数还有SR2的地址</p><p>【5:0】是用来选择ALU的就散哪种的。</p><p>队友【20:16】和【15:11】DR可能是上面的其中一种，所以有DRMUX</p><p>PC也有可能因为JR指令所有有32位的赋值</p><h2 id="DLX的指令执行阶段"><a href="#DLX的指令执行阶段" class="headerlink" title="DLX的指令执行阶段"></a>DLX的指令执行阶段</h2><ul><li>取指令(同时PC+4)<ul><li>PC-&gt;MAR<ul><li>PC+4-&gt;ALUOut</li></ul></li><li>M[MAR]-&gt;MDR<ul><li>AlUout-&gt;PC</li></ul></li><li>MDR-&gt;IR</li></ul></li></ul><p><img src="https://pic.mikumifa.cn/2022/11/02/7fe1408c9a1a7.png"></p><ul><li>译码&#x2F;取寄存器<ul><li>IR[31:26]用来决定余下的26位有什么工作</li><li>IR[25:21]-&gt;A</li><li>IR[20:16]-&gt;B</li><li>PC+4+SEXT(IR[15:0])-&gt;ALUOUT</li></ul></li></ul><p><img src="https://pic.mikumifa.cn/2022/11/02/4790379819541.png"></p><p><img src="https://pic.mikumifa.cn/2022/11/02/9e8d61ead8dcb.png"></p><ul><li>执行&#x2F;有效地址&#x2F;完成分支</li></ul><p>A op B,或者计算地址，或者完成分支</p><p><img src="https://pic.mikumifa.cn/2022/11/02/c4dbdc59cf5b1.png"></p><p><img src="https://pic.mikumifa.cn/2022/11/02/9e7a26cbf9daf.png"></p><p>ADD：A+B-》ALUOut</p><p>LW：A+SEXT（IR【15:0】）-》ALUOUt</p><p>BEQZ：A&#x3D;&#x3D;0-》Z</p><p>if（Z）</p><p>​ALUOUT-》PC</p><ul><li>访问内存</li></ul><p><img src="https://pic.mikumifa.cn/2022/11/02/89bbbc383f1b5.png"></p><p><img src="https://pic.mikumifa.cn/2022/11/02/4c54bf0bd435f.png"></p><ul><li>写回</li></ul><p><img src="https://pic.mikumifa.cn/2022/11/02/a4852f4ae6603.png"></p><p><img src="https://pic.mikumifa.cn/2022/11/02/43acb165a67d2.png"></p><p><img src="https://pic.mikumifa.cn/2022/11/02/2b8ee3568eebc.png"></p><p><img src="https://pic.mikumifa.cn/2022/11/02/603471c8f97ef.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>概统习题和补充知识</title>
      <link href="/2023/03/05/%E6%A6%82%E7%BB%9F%E4%B9%A0%E9%A2%98%E5%92%8C%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/03/05/%E6%A6%82%E7%BB%9F%E4%B9%A0%E9%A2%98%E5%92%8C%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="多维随机变量函数的换元法"><a href="#多维随机变量函数的换元法" class="headerlink" title="多维随机变量函数的换元法"></a>多维随机变量函数的换元法</h2><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/qq_pic_merged_1667648121494.jpg" alt="qq_pic_merged_1667648121494"><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/qq_pic_merged_1667648091010.jpg" alt="qq_pic_merged_1667648098987"><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/IMG_20221105_163508.jpg" alt="IMG_20221105_163508"></p><p><a href="https://www.bilibili.com/video/BV1wU4y1M74v/?spm_id_from=333.999.0.0&vd_source=a891f2946c7aad7edc1aa0f4b2073d6e">一道考察很全面的常规概率题_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1oN411f77u/?spm_id_from=333.999.0.0&vd_source=a891f2946c7aad7edc1aa0f4b2073d6e">表格积分法（附19年数一最难题的快速计算过程）_哔哩哔哩_bilibili</a></p><p><a href="https://www.bilibili.com/video/BV1Va411e7Nf/?spm_id_from=333.999.0.0&vd_source=a891f2946c7aad7edc1aa0f4b2073d6e">伽马函数，你必须得会_哔哩哔哩_bilibili</a></p><h2 id="联合分布和边缘密度函数的例题"><a href="#联合分布和边缘密度函数的例题" class="headerlink" title="联合分布和边缘密度函数的例题"></a>联合分布和边缘密度函数的例题</h2><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/IMG_20221105_192906.jpg" alt="IMG_20221105_192906"><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/qq_pic_merged_1667648074239.jpg" alt="qq_pic_merged_1667648074239"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/qq_pic_merged_1667648064742.jpg" alt="qq_pic_merged_1667648064742"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>卷积公式</title>
      <link href="/2023/03/05/%E5%8D%B7%E7%A7%AF%E5%85%AC%E5%BC%8F/"/>
      <url>/2023/03/05/%E5%8D%B7%E7%A7%AF%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="卷积公式yyds"><a href="#卷积公式yyds" class="headerlink" title="卷积公式yyds"></a>卷积公式yyds</h2><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/IMG_20221105_203603.jpg" alt="IMG_20221105_203603"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/qq_pic_merged_1667651829414.jpg" alt="qq_pic_merged_1667651829414"><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/qq_pic_merged_1667651836262.jpg" alt="qq_pic_merged_1667651836262"><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/IMG_20221105_203619.jpg" alt="IMG_20221105_203619"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Beautiful C++ - STL Algorithms C++</title>
      <link href="/2023/03/05/Beautiful%20C++%20-%20STL%20Algorithms%20C++/"/>
      <url>/2023/03/05/Beautiful%20C++%20-%20STL%20Algorithms%20C++/</url>
      
        <content type="html"><![CDATA[<h1 id="Beautiful-C-STL-Algorithms-C"><a href="#Beautiful-C-STL-Algorithms-C" class="headerlink" title="Beautiful C++ - STL Algorithms C++"></a>Beautiful C++ - STL Algorithms C++</h1><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221106140725783.png" alt="image-20221106140725783"></p><h2 id="Algorithms-recognize-the-function"><a href="#Algorithms-recognize-the-function" class="headerlink" title="Algorithms: recognize the function"></a>Algorithms: recognize the function</h2><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221106141705255.png" alt="image-20221106141705255"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> simple=<span class="built_in">count</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),target);</span><br><span class="line"><span class="type">int</span> simple=<span class="built_in">coour</span>(<span class="built_in">begin</span>(v),<span class="built_in">end</span>(v),target);<span class="comment">//this may be better</span></span><br><span class="line"><span class="type">int</span> mouths=<span class="built_in">count_if</span>(<span class="built_in">begin</span>(v),<span class="built_in">end</span>(v),[](<span class="keyword">auto</span> elem)&#123;</span><br><span class="line"> <span class="keyword">return</span> ==;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">itr_swap()/交换指针指向的地址</span><br><span class="line">swap_ranges(begin(v1),find(begin(v1),end(v1),6),begin(v2));//交换一个范围</span><br></pre></td></tr></table></figure><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">operator=，copy_if(),copy_n(),//没有改变顺序</span><br><span class="line">//首先保证size()是够得</span><br><span class="line">copy(begin(source),end(source),begin(v2));</span><br><span class="line">auto v3=source;//可以直接赋值，如果直接全部copy，尽量使用=</span><br><span class="line">copy的第二个参数时不会被cpoy的</span><br><span class="line">copy_n(begin(source),3,begin(dst))//copy前三个</span><br><span class="line">copy_backword//以第三个参数为结尾</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树遍历相关的</title>
      <link href="/2023/03/05/%E6%A0%91%E9%81%8D%E5%8E%86%E7%9B%B8%E5%85%B3%E7%9A%84/"/>
      <url>/2023/03/05/%E6%A0%91%E9%81%8D%E5%8E%86%E7%9B%B8%E5%85%B3%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树的确定"><a href="#二叉树的确定" class="headerlink" title="二叉树的确定"></a>二叉树的确定</h2><p>先序中序确定二叉树，后序和中序确定二叉树，必须要有中序，</p><p>先序和后序提供了根节点，然后通过根节点确定左右子树</p><iframe src="//player.bilibili.com/player.html?aid=250115889&bvid=BV1Wv411A71h&cid=397257876&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221106152803415.png" alt="image-20221106152803415"></p><iframe src="//player.bilibili.com/player.html?aid=506254678&bvid=BV1Xu411d7qf&cid=431424735&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>已知先&#x2F;后和中，求后&#x2F;先遍历</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221106153909323.png" alt="image-20221106153909323"></p><iframe src="//player.bilibili.com/player.html?aid=928609724&bvid=BV1eT4y1N7tV&cid=279071947&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>写出前，中，后序遍历</p><p>（根左右）前序：</p><p>左根右，中序：</p><p>左右根，后序：</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221106154327905.png" alt="image-20221106154327905"></p><p>先写出根节点的顺序，间隔大一点，然后按照跟左右的方式像外面扩展</p><h2 id="几种非递归的遍历"><a href="#几种非递归的遍历" class="headerlink" title="几种非递归的遍历"></a>几种非递归的遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrderIterative</span><span class="params">(treeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == root)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 空树</span></span><br><span class="line"></span><br><span class="line">    stack&lt;treeNode *&gt; nodeStack;  <span class="comment">// 创建一个栈保存节点</span></span><br><span class="line">    treeNode *currentNode = root; <span class="comment">// 维护一个当前节点指针</span></span><br><span class="line">    treeNode *visitedNode = root; <span class="comment">// 保存上次一访问的节点, 初始化为root是利用二叉树是无环图</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点非空，或栈非空时迭代处理</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode || !nodeStack.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前节点非空，沿着左子树方向入栈</span></span><br><span class="line">        <span class="keyword">while</span> (currentNode)</span><br><span class="line">        &#123;</span><br><span class="line">            nodeStack.<span class="built_in">push</span>(currentNode);</span><br><span class="line">            currentNode = currentNode-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode = nodeStack.<span class="built_in">top</span>(); <span class="comment">// 取栈顶元素</span></span><br><span class="line">        <span class="comment">// 如果栈顶元素有右子树，且未被访问</span></span><br><span class="line">        <span class="keyword">if</span> (currentNode-&gt;right &amp;&amp; currentNode-&gt;right != visitedNode)</span><br><span class="line">        &#123;</span><br><span class="line">            currentNode = currentNode-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 子树为空或被访问过</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, currentNode-&gt;data); <span class="comment">// 访问节点数据</span></span><br><span class="line">            visitedNode = currentNode;        <span class="comment">// 记录当前访问的节点</span></span><br><span class="line">            currentNode = <span class="literal">NULL</span>;               <span class="comment">// 当前节点置为NULL，防止重复访问左子树</span></span><br><span class="line">            nodeStack.<span class="built_in">pop</span>();                  <span class="comment">// 出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderIterative</span><span class="params">(treeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == root)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 空树</span></span><br><span class="line"></span><br><span class="line">    stack&lt;treeNode *&gt; nodeStack;  <span class="comment">// 创建一个栈保存节点</span></span><br><span class="line">    treeNode *currentNode = root; <span class="comment">// 维护一个当前节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点非空，或栈非空时迭代处理</span></span><br><span class="line">    <span class="keyword">while</span> (currentNode || !nodeStack.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当前节点非空，沿着左子树方向入栈</span></span><br><span class="line">        <span class="keyword">while</span> (currentNode)</span><br><span class="line">        &#123;</span><br><span class="line">            nodeStack.<span class="built_in">push</span>(currentNode);</span><br><span class="line">            currentNode = currentNode-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时栈顶节点没有左子树，或已经访问完左子树</span></span><br><span class="line">        currentNode = nodeStack.<span class="built_in">top</span>();    <span class="comment">// 取栈顶节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, currentNode-&gt;data); <span class="comment">// 访问节点数据</span></span><br><span class="line">        nodeStack.<span class="built_in">pop</span>();                  <span class="comment">// 出栈</span></span><br><span class="line">        currentNode = currentNode-&gt;right; <span class="comment">// 将当前节点设为右子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrderIterative</span><span class="params">(treeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == root)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 空树</span></span><br><span class="line"></span><br><span class="line">    stack&lt;treeNode *&gt; nodeStack; <span class="comment">// 创建一个栈保存节点</span></span><br><span class="line">    nodeStack.<span class="built_in">push</span>(root);        <span class="comment">// 根节点进栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!nodeStack.<span class="built_in">empty</span>()) <span class="comment">// 栈非空时迭代处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        treeNode *node = nodeStack.<span class="built_in">top</span>(); <span class="comment">// 保存栈顶节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data);        <span class="comment">// 访问节点数据</span></span><br><span class="line">        nodeStack.<span class="built_in">pop</span>();                  <span class="comment">// 栈顶节点出栈</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子节点入栈</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            nodeStack.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            nodeStack.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B树的关键字的个数</p><iframe src="//player.bilibili.com/player.html?aid=556014915&bvid=BV11e4y1X7h9&cid=778224013&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>关键字数：</p><p>先知道B数一个节点最多最少有多少关键字数，</p><p>然后至少就是用最少关键字来构造最多就是用最多的关键数来构造，分支数是关键数加+1，（<strong>注意至少的时候，根节点最少是1个关键字</strong>）</p><p>53个关键字构造最短的二叉树</p><p><code>1+2(2+2*3+2*3*3)=53</code></p><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><p>log<del>2</del>（n+1）上取整，到，n</p><p>n个节点，n-1条边。</p><p>度数2的节点数+1&#x3D;叶节点数</p><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>有左孩子则必有有孩子，有有孩子则必有左孩子</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221106170727280.png" alt="image-20221106170727280"></p><p>树转化为二叉树，先序遍历相同，后序遍历等于二叉树的中序遍历</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221106170915883.png" alt="image-20221106170915883"></p><p>森林</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221106171117343.png" alt="image-20221106171117343"></p><p>把根节点连起来即可</p><p>森林的root是第一课树的root，左子树的节点数+1&#x3D;tree1的节点数</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bungeecord跨服开服</title>
      <link href="/2023/03/05/bungeecord%E8%B7%A8%E6%9C%8D%E5%BC%80%E6%9C%8D/"/>
      <url>/2023/03/05/bungeecord%E8%B7%A8%E6%9C%8D%E5%BC%80%E6%9C%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="bungeecord跨服"><a href="#bungeecord跨服" class="headerlink" title="bungeecord跨服"></a>bungeecord跨服</h1><h2 id="前置："><a href="#前置：" class="headerlink" title="前置："></a>前置：</h2><p>资源下载：<a href="https://ci.md-5.net/job/BungeeCord/lastSuccessfulBuild/artifact/bootstrap/target/BungeeCord.jar">点击下载</a></p><p>linux创建<code>start.sh</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$( dirname -- <span class="string">&quot;<span class="variable">$0</span>&quot;</span> )</span>&quot;</span></span><br><span class="line">java -Xms512M -Xmx512M -jar BungeeCord.jar</span><br></pre></td></tr></table></figure><p>windows创建<code>start.bat</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line">java -Xms512M -Xmx512M -jar BungeeCord.jar</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h2 id="服务器创建"><a href="#服务器创建" class="headerlink" title="服务器创建"></a>服务器创建</h2><p>使用自己已经有的服务器，要有java8的环境</p><h2 id="拷贝文件到服务器内"><a href="#拷贝文件到服务器内" class="headerlink" title="拷贝文件到服务器内"></a>拷贝文件到服务器内</h2><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221106181438714.png" alt="image-20221106181438714"></p><p>BC文件夹里面是<code>start.sh</code>和<code>BungeeCord.jar</code>文件</p><p>mc2是我的mc服务器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> BC</span><br><span class="line"><span class="built_in">chmod</span> u+x start.sh <span class="comment">#使用这个指令之后才有权限否则会出现Permission denied</span></span><br><span class="line">./start.sh <span class="comment">#启动</span></span><br></pre></td></tr></table></figure><p>成功之后会出现下面</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">18:08:25 [INFO] Loaded plugin reconnect_yaml version git:reconnect_yaml:1.19-R0.1-SNAPSHOT:2d369e8:1664 by SpigotMC</span><br><span class="line">18:08:25 [INFO] Loaded plugin cmd_find version git:cmd_find:1.19-R0.1-SNAPSHOT:2d369e8:1664 by SpigotMC</span><br><span class="line">18:08:25 [INFO] Loaded plugin cmd_server version git:cmd_server:1.19-R0.1-SNAPSHOT:2d369e8:1664 by SpigotMC</span><br><span class="line">18:08:25 [INFO] Loaded plugin cmd_alert version git:cmd_alert:1.19-R0.1-SNAPSHOT:2d369e8:1664 by SpigotMC</span><br><span class="line">18:08:25 [INFO] Loaded plugin cmd_send version git:cmd_send:1.19-R0.1-SNAPSHOT:2d369e8:1664 by SpigotMC</span><br><span class="line">18:08:25 [INFO] Loaded plugin cmd_list version git:cmd_list:1.19-R0.1-SNAPSHOT:2d369e8:1664 by SpigotMC</span><br><span class="line">18:08:25 [WARNING] Forced host server pvp is not defined</span><br><span class="line">18:08:25 [INFO] Enabled plugin reconnect_yaml version git:reconnect_yaml:1.19-R0.1-SNAPSHOT:2d369e8:1664 by SpigotMC</span><br><span class="line">18:08:25 [INFO] Enabled plugin cmd_find version git:cmd_find:1.19-R0.1-SNAPSHOT:2d369e8:1664 by SpigotMC</span><br><span class="line">18:08:25 [INFO] Enabled plugin cmd_server version git:cmd_server:1.19-R0.1-SNAPSHOT:2d369e8:1664 by SpigotMC</span><br><span class="line">18:08:25 [INFO] Enabled plugin cmd_alert version git:cmd_alert:1.19-R0.1-SNAPSHOT:2d369e8:1664 by SpigotMC</span><br><span class="line">18:08:25 [INFO] Enabled plugin cmd_send version git:cmd_send:1.19-R0.1-SNAPSHOT:2d369e8:1664 by SpigotMC</span><br><span class="line">18:08:25 [INFO] Enabled plugin cmd_list version git:cmd_list:1.19-R0.1-SNAPSHOT:2d369e8:1664 by SpigotMC</span><br><span class="line">18:08:25 [INFO] Listening on /0.0.0.0:25577</span><br></pre></td></tr></table></figure><p>退出是输入<code>end</code></p><h2 id="config-yml的配置"><a href="#config-yml的配置" class="headerlink" title="config.yml的配置"></a>config.yml的配置</h2><p>这里随便使用编译器了，我使用vim和vscode都差不多，不过服务器暂时没配vscode，所以用vim.</p><p><a href="https://www.spigotmc.org/wiki/bungeecord-configuration-guide/">参考的wiki链接</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim config.yml <span class="comment">#进入config.yml</span></span><br></pre></td></tr></table></figure><p>进入后输入&#x2F;ip_forword,查找ip_forword，<code>i</code>键进入<code>insert</code>模式改为true</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221106182415018.png" alt="image-20221106182415018"></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列举一下哪些要改</span></span><br><span class="line"><span class="attr">force_default_server:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">ip_forword:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">max_players:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">query_port:</span> <span class="number">25577</span> <span class="comment">#这个看情况，不过要记住，BC端进入的端口就是这个端口</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">force_default_server</span> <span class="comment">#说白了就是强制登录在一个特定服务器里面</span></span><br><span class="line"><span class="attr">Default:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">Type:</span> <span class="string">Boolean</span></span><br><span class="line"><span class="attr">Description:</span> <span class="string">If</span> <span class="literal">true</span><span class="string">,</span> <span class="string">the</span> <span class="string">player</span> <span class="string">will</span> <span class="string">always</span> <span class="string">connect</span> <span class="string">to</span> <span class="string">the</span> <span class="string">default</span> <span class="string">servers</span> <span class="string">specified</span> <span class="string">in</span> <span class="string">the</span> <span class="string">priorities</span> <span class="string">list</span> <span class="string">when</span> <span class="string">they</span> <span class="string">join</span> <span class="string">the</span> <span class="string">server.</span> <span class="string">If</span> <span class="literal">false</span><span class="string">,</span> <span class="attr">the player will join the server they were last connected to. Note:</span> <span class="string">forced_hosts</span> <span class="string">does</span> <span class="string">NOT</span> <span class="string">override</span> <span class="string">this.</span> <span class="string">To</span> <span class="string">make</span> <span class="string">the</span> <span class="string">forced_hosts</span> <span class="string">setting</span> <span class="string">work,</span> <span class="string">set</span> <span class="string">this</span> <span class="string">to</span> <span class="string">false.</span> <span class="string">Should</span> <span class="string">be</span> <span class="string">kept</span> <span class="string">on</span> <span class="string">for</span> <span class="string">cracked</span> <span class="string">server!</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ip_forward</span></span><br><span class="line"><span class="attr">Default:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">Type:</span> <span class="string">Boolean</span></span><br><span class="line"><span class="attr">Description:</span> <span class="string">Whether</span> <span class="string">to</span> <span class="string">enable</span> <span class="string">IP</span> <span class="string">(which</span> <span class="string">forwards</span> <span class="string">the</span> <span class="string">players</span> <span class="literal">true</span> <span class="string">IP</span> <span class="string">to</span> <span class="string">Bukkit,</span> <span class="string">rather</span> <span class="string">than</span> <span class="string">the</span> <span class="string">proxy</span> <span class="string">IP)</span> <span class="string">and</span> <span class="string">UUID</span> <span class="string">forwarding</span> <span class="string">(which</span> <span class="string">forwards</span> <span class="string">the</span> <span class="string">players</span> <span class="literal">true</span> <span class="string">online-mode</span> <span class="string">UUID</span> <span class="string">to</span> <span class="string">Bukkit,</span> <span class="string">rather</span> <span class="string">than</span> <span class="string">an</span> <span class="string">offline-mode</span> <span class="string">username</span> <span class="string">hash!)</span></span><br><span class="line"><span class="string">If</span> <span class="string">you&#x27;re</span> <span class="attr">running an online-mode:</span> <span class="literal">true</span> <span class="string">server,</span> <span class="string">It</span> <span class="string">is</span> <span class="string">highly</span> <span class="string">recommended</span> <span class="string">you</span> <span class="string">use</span> <span class="string">this</span> <span class="string">option!</span></span><br><span class="line"><span class="string">If</span> <span class="string">using</span> <span class="string">this</span> <span class="string">option,</span> <span class="string">please</span> <span class="string">follow</span> <span class="string">this</span> <span class="string">guide</span> <span class="string">to</span> <span class="string">ensure</span> <span class="string">that</span> <span class="string">you</span> <span class="string">have</span> <span class="string">enabled</span> <span class="string">it</span> <span class="string">correctly.</span></span><br></pre></td></tr></table></figure><p>有什么其他想改的可以自己改</p><h4 id="下面是servers的配置"><a href="#下面是servers的配置" class="headerlink" title="下面是servers的配置"></a>下面是servers的配置</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">skyCraft:</span></span><br><span class="line"> <span class="attr">address:</span> <span class="string">localhost:25565</span></span><br><span class="line"> <span class="attr">restricted:</span> <span class="literal">false</span></span><br><span class="line"> <span class="attr">motd:</span> <span class="string">&#x27;&amp;1Just another BungeeCord - Forced Host&#x27;</span></span><br></pre></td></tr></table></figure><p><em>Note: restricted prevents players from joining the server unless they have the bungeecord.server.[servername] permission<br>Type:</em> Map<br><em>Description:</em> Within this section, you will list all the servers that will be connected to via the BungeeCord instance. It is recommended to use lowercase for the names of the servers.</p><p>按照自己的服务器要求来</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改之后设置进服之后是哪个服，我设置的是skyCraft,名字要servers设置的一样</span></span><br><span class="line"><span class="attr">priorities:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">skyCraft</span></span><br></pre></td></tr></table></figure><h2 id="然后发现FabricProxy只支持1-18以下的，所以失败了，润！！！！！"><a href="#然后发现FabricProxy只支持1-18以下的，所以失败了，润！！！！！" class="headerlink" title="然后发现FabricProxy只支持1.18以下的，所以失败了，润！！！！！"></a>然后发现<strong>FabricProxy</strong>只支持1.18以下的，所以失败了，润！！！！！</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Velocity互通服</title>
      <link href="/2023/03/05/Velocity%E4%BA%92%E9%80%9A%E6%9C%8D/"/>
      <url>/2023/03/05/Velocity%E4%BA%92%E9%80%9A%E6%9C%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Velocity互通服"><a href="#Velocity互通服" class="headerlink" title="Velocity互通服"></a>Velocity互通服</h2><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p><a href="https://papermc.io/downloads#Velocity">Velocity下载</a></p><p><a href="https://modrinth.com/mod/fabricproxy-lite/versions">FabricProxy-Lite下载</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>老样子，放Velocity到一个文件夹，然后</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar velocityxxxxx.jar <span class="comment">#根据自己的版本来看</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[19:19:27 INFO]: Booting up Velocity 3.1.2-SNAPSHOT (git-1a1391a5-b155)...</span><br><span class="line">[19:19:27 INFO]: Loading localizations...</span><br><span class="line">[19:19:28 INFO]: Connections will use epoll channels, libdeflate (Linux x86_64) compression, OpenSSL 1.0.x (Linux x86_64) ciphers</span><br><span class="line">[19:19:28 WARN]: Player info forwarding is disabled! All players will appear to be connecting from the proxy and will have offline-mode UUIDs.</span><br><span class="line">[19:19:28 INFO]: Loading plugins...</span><br><span class="line">[19:19:28 INFO]: Loaded 0 plugins</span><br><span class="line">[19:19:28 INFO]: Listening on /[0:0:0:0:0:0:0:0%0]:25577</span><br><span class="line">[19:19:28 INFO]: Velocity and some of its plugins collect metrics and send them to bStats (https://bStats.org).</span><br><span class="line">[19:19:28 INFO]: bStats collects some basic information for plugin authors, like how many people use</span><br><span class="line">[19:19:28 INFO]: their plugin and their total player count. It&#x27;s recommended to keep bStats enabled, but</span><br><span class="line">[19:19:28 INFO]: if you&#x27;re not comfortable with this, you can opt-out by editing the config.txt file in</span><br><span class="line">[19:19:28 INFO]: the &#x27;/plugins/bStats/&#x27; folder and setting enabled to false.</span><br><span class="line">[19:19:28 INFO]: Done (1.07s)!</span><br></pre></td></tr></table></figure><p>上面是成功的提示，端口25577</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置<code>velocity.toml</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi velocity.toml</span><br></pre></td></tr></table></figure><p>bind项为绑定的ip和端口号，一般只需要修改端口号即可，保持前面的0.0.0.0不变</p><p>motd为服务器的描述文字</p><p>online-mode是否开启正版验证</p><p>force-key-authentication 改成false</p><p>player-info-forwarding-mode项将引号中的内容改为modern</p><p>ping-passthrough项将引号中的内容改为all</p><p>[servers]中是子服务器列表</p><p>try中的内容是尝试登录服务器的顺序，将默认登录的子服务器放在第一位，多个服务器以逗号隔开</p><p>[query]下的port项，和bind中的端口号保持一致即可 </p><p><a href="https://docs.papermc.io/velocity">官方文档</a></p><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><p>装一下<a href="https://modrinth.com/mod/fabricproxy-lite/versions">FabricProxy-Lite</a>下载这个mod</p><p>服务器启动一下，然后关掉</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> config/</span><br><span class="line">vi FabricProxy-Lite.toml</span><br></pre></td></tr></table></figure><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221106194139863.png" alt="image-20221106194139863"></p><p>内容改成这样，其中<code>secret</code>是<code>Velocity</code>路径下的<code>forwarding .secret</code></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221106194244546.png" alt="image-20221106194244546"></p><h2 id="小写一个start-sh"><a href="#小写一个start-sh" class="headerlink" title="小写一个start.sh"></a>小写一个start.sh</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">java -jar velocity-3.1.2-SNAPSHOT-155.jar</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+x start.sh <span class="comment">#给特权</span></span><br><span class="line">./start.sh <span class="comment">#启动</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据报分片</title>
      <link href="/2023/03/05/%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87/"/>
      <url>/2023/03/05/%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h2 id="数据报分片"><a href="#数据报分片" class="headerlink" title="数据报分片"></a>数据报分片</h2><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/40.png" alt="img"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/3.png" alt="img"><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/40.png" alt="img"><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/4.png" alt="img"></p><ul><li>区分数据部分长度和数据报的长度，数据报的长度是数据部分长度加上首部长度</li><li>标识，相同的标识号会合并(相同标识号的报文是一个大报文，可以合并的)</li><li>DF标志位（Don’t fragment）1不允许做分片，0允许做分片</li><li>MF(more fragment)标志位：0表示最后一个分片,1是指后面还有分片</li><li>片偏移单位是8个字节，为每一个分片的开头标一个数字，除以8</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><blockquote></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CDMA,地址聚合,路由表更新</title>
      <link href="/2023/03/05/CDMA,%E5%9C%B0%E5%9D%80%E8%81%9A%E5%90%88,%E8%B7%AF%E7%94%B1%E8%A1%A8%E6%9B%B4%E6%96%B0/"/>
      <url>/2023/03/05/CDMA,%E5%9C%B0%E5%9D%80%E8%81%9A%E5%90%88,%E8%B7%AF%E7%94%B1%E8%A1%A8%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="码分复用-CDM-Code-Division-Multiplexing"><a href="#码分复用-CDM-Code-Division-Multiplexing" class="headerlink" title="码分复用 CDM (Code Division Multiplexing)"></a>码分复用 CDM (Code Division Multiplexing)</h1><ul><li><p>要求不同基站的1的编码是相互正交的，基站2产生的01序列编码不能对基站1的序列编码产生影响。</p></li><li><p>多个基站使用互相正交的编码，互相不影响，进行复用</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221107091035459.png" alt="image-20221107091035459"></p></li></ul><h1 id="地址聚合"><a href="#地址聚合" class="headerlink" title="地址聚合"></a>地址聚合</h1><p>化成二进制然后找最长的前缀</p><h1 id="路由表更新"><a href="#路由表更新" class="headerlink" title="路由表更新"></a>路由表更新</h1><h2 id="内部网关协议的分类：DVP（Distance-Vector-Protocols）-and-LSP（Link-State-Protocols）"><a href="#内部网关协议的分类：DVP（Distance-Vector-Protocols）-and-LSP（Link-State-Protocols）" class="headerlink" title="内部网关协议的分类：DVP（Distance-Vector Protocols） and LSP（Link State Protocols）"></a>内部网关协议的分类：DVP（Distance-Vector Protocols） and LSP（Link State Protocols）</h2><p>距离矢量协议(Distance-Vector Protocols，RIP, IGRP)</p><p>链路状态协议(Link State Protocols, OSPF)</p><h2 id="下面的应该是距离矢量协议"><a href="#下面的应该是距离矢量协议" class="headerlink" title="下面的应该是距离矢量协议"></a>下面的应该是距离矢量协议</h2><p>RIP路由更新（Routing Information Protocol)（有，就是给你原表，给出相邻节点提供的表，更新一下）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 把发来的路由表的下一跳都改为发来的路由器编号，距离都加1</span><br><span class="line">2. 如果原来的路由表没有目的网络，更新</span><br><span class="line">   如果原来的路由表有，下一跳和目的网络一样的，不管距离大小，都更新</span><br><span class="line">   如果原来的路由表，有相同目的网络的但是下一跳不一样，保留距离小的。</span><br><span class="line">   没有的物理表，保持原样</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IP地址的划分</title>
      <link href="/2023/03/05/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%92%E5%88%86/"/>
      <url>/2023/03/05/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%92%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="IP地址的划分"><a href="#IP地址的划分" class="headerlink" title="IP地址的划分"></a>IP地址的划分</h2><ol><li>IP地址主要通过第一个字节进行划分</li><li>0–127 Class A address A类地址（0和127不可以指派）</li><li>128-191 Class B address B类地址（0和全1不要指派）</li><li>192–223 Class C address C类地址（0和全1不要指派）</li><li>224–239 Class D – Multicast D类地址：多播：视频点播的原理也是组播(多播)（组播地址）</li><li>240–255 Class E - Research E类地址：研究</li></ol><p>私有（内网）IP地址范围：（private address）</p><p>A类：10.0.0.0-10.255.255.255<br>B类：172.16.0.0-172.31.255.255<br>C类：192.168.0.0-192.168.255.255</p><p>上述地址都是用作局域网的内部网段。</p><p>所谓私有地址就是在A、B、C三类IP地址中保留下来为企业内部网络分配地址时所使用的IP地址。</p><p>上面的数字都要记住</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2022-11-09-有效数字</title>
      <link href="/2023/03/05/2022-11-09-%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97/"/>
      <url>/2023/03/05/2022-11-09-%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="有效数字"><a href="#有效数字" class="headerlink" title="有效数字"></a><a href="https://leetcode.cn/problems/valid-number/description/">有效数字</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Hard (27.50%)</td><td align="center">334</td><td align="center">-</td></tr></tbody></table><details style="color: rgb(238, 255, 255); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Tags</strong></summary><p><a href="https://leetcode.com/tag/math" title="https://leetcode.com/tag/math" style="color: var(--vscode-textLink-foreground);"><code style="color: var(--vscode-textLink-foreground); white-space: pre-wrap;"></code></a><a href="https://leetcode.com/tag/string" title="https://leetcode.com/tag/string" style="color: var(--vscode-textLink-foreground);"><code style="color: var(--vscode-textLink-foreground); white-space: pre-wrap;"></code></a></p></details><details style="color: rgb(238, 255, 255); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Companies</strong></summary><p><code style="color: var(--vscode-textPreformat-foreground); white-space: pre-wrap;"></code></p></details><p><strong>有效数字</strong>（按顺序）可以分成以下几个部分：</p><ol><li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li><li>（可选）一个 <code>&#39;e&#39;</code> 或 <code>&#39;E&#39;</code> ，后面跟着一个 <strong>整数</strong></li></ol><p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>下述格式之一：<ol><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code></li><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code> ，后面再跟着至少一位数字</li><li>一个点 <code>&#39;.&#39;</code> ，后面跟着至少一位数字</li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>至少一位数字</li></ol><p>部分有效数字列举如下：<code>[&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;]</code></p><p>部分无效数字列举如下：<code>[&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;]</code></p><p>给你一个字符串 <code>s</code> ，如果 <code>s</code> 是一个 <strong>有效数字</strong> ，请返回 <code>true</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;0&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;e&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;.&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>&#39;+&#39;</code> ，减号 <code>&#39;-&#39;</code> ，或者点 <code>&#39;.&#39;</code> 。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSmall</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = s.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = s.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">empty</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i] &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27;.&#x27;</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i] &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == s.<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (i++; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i] &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInt</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = s.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i] &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isNumber</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isSmall</span>(s) || <span class="built_in">isInt</span>(s))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;e&#x27;</span> || s[i] == <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="built_in">isSmall</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, i)) || <span class="built_in">isInt</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, i))) &amp;&amp; <span class="built_in">isInt</span>(s.<span class="built_in">substr</span>(i + <span class="number">1</span>)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>自动机的做法等等再写</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>外部存储器储存</title>
      <link href="/2023/03/05/%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8%E5%82%A8%E5%AD%98/"/>
      <url>/2023/03/05/%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8%E5%82%A8%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h2><p>磁盘是由涂有可磁化材料的非磁性材料（基材）构成的圆形盘片</p><p>材料：铝，铝合金，玻璃</p><h3 id="玻璃基材的优势（稳定可靠、为存储更多信息提供基础）"><a href="#玻璃基材的优势（稳定可靠、为存储更多信息提供基础）" class="headerlink" title="玻璃基材的优势（稳定可靠、为存储更多信息提供基础）"></a>玻璃基材的优势（稳定可靠、为存储更多信息提供基础）</h3><p>• 改善磁膜表面的均匀性，提高磁盘的可靠性 </p><p>• 显著减少整体表面瑕疵，以帮助减少读写错误 </p><p>• 能够支持（磁头）较低的飞行高度</p><p> • 更高的硬度，使磁盘转动时更加稳定 </p><p>• 更强的抗冲击和抗损伤能力</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>略<img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111092036516.png" alt="image-20221111092036516"></p><p>磁盘存储器每个盘片表面有一个读写磁头， 所有磁头通过机械方式固定在一起，同时 移动</p><p>在任何时候，所有磁头都位于距磁盘中心 等距离的磁道上</p><ul><li><p>磁头：产生电磁场来正确的读写</p><ul><li>磁头越窄，电磁感应越弱，离磁盘越近</li><li>更高的数据密度要求更窄的磁头和磁道，有更高的出错风险</li><li>硬盘密封</li></ul></li><li><p>读写机制</p><ul><li>磁盘静止，而盘片在其下方旋转</li><li>磁头的数量<ul><li>单词头，读和写公用一个磁头</li><li>双磁头，使用一个单独的磁头读写。</li></ul></li></ul></li><li><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111093222787.png" alt="image-20221111093222787"></p><h3 id="数据组织"><a href="#数据组织" class="headerlink" title="数据组织"></a>数据组织</h3><p>盘片上的数据组织为同心圆心环，磁道</p><p>数据以扇区的形式传输到磁盘或者传出（默认值为512B）</p><p>相邻磁道和扇区之间有间隙，磁道的编号从外向内递增，磁头静止时在磁道0的外侧</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111095357374.png" alt="image-20221111095357374"></p><p>总结：同心圆磁道，从外向内递增。扇形扇区</p><p>扇区划分</p><p>恒定角速度，（恒定的数据传输率），优点：能以磁道号和扇区号直接寻址各个数据块</p><p>缺点：磁盘存储容量受到了最内层磁道所能实现的最大记录密度的限制、</p><p><strong>多带式记录，多重区域记录</strong></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111100001726.png" alt="image-20221111100001726"></p></li></ul><h3 id="柱面"><a href="#柱面" class="headerlink" title="柱面"></a>柱面</h3><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111100320718.png" alt="image-20221111100320718"></p><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111100501798.png" alt="image-20221111100501798"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111100825296.png" alt="image-20221111100825296"></p><h3 id="I-x2F-O操作"><a href="#I-x2F-O操作" class="headerlink" title="I&#x2F;O操作"></a>I&#x2F;O操作</h3><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111101004303.png" alt="image-20221111101004303"></p><p>定位磁道-》定位扇区，数据传输</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111101452895.png" alt="image-20221111101452895"></p><p>寻道时间只考虑一次。</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111101754294.png" alt="image-20221111101754294"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111101809350.png" alt="image-20221111101809350"></p><p>转速延迟1&#x2F;（2*15000&#x2F;60）&#x3D;2ms</p><p>读取500个扇区，1&#x2F;（15000&#x2F;60）&#x3D;4ms（就是旋转一圈的时间）</p><p>顺序的话，寻道时间就计算一次，</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111102436496.png" alt="image-20221111102436496"></p><p>随机的话，每一个磁道都要去找，一个扇区的时间是（就是旋转一圈的时间&#x2F;500）&#x3D;0.008ms</p><p>所以可以求出总时间；</p><h2 id="磁头寻道-x2F-磁盘调度算法"><a href="#磁头寻道-x2F-磁盘调度算法" class="headerlink" title="磁头寻道&#x2F;磁盘调度算法"></a>磁头寻道&#x2F;磁盘调度算法</h2><p>目标：当有多个访问磁盘任务时候，寻道时间最短</p><p>常见的磁头寻址&#x2F;磁盘调度算法</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111102935478.png" alt="image-20221111102935478"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111102957903.png" alt="image-20221111102957903"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111103003048.png" alt="image-20221111103003048"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111103007873.png" alt="image-20221111103007873"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111103012991.png" alt="image-20221111103012991"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111103018440.png" alt="image-20221111103018440"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111103024305.png" alt="image-20221111103024305"></p><h2 id="光存储器"><a href="#光存储器" class="headerlink" title="光存储器"></a>光存储器</h2><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221110162302322.png" alt="image-20221110162302322"></p><h3 id="CD-和CD-ROM"><a href="#CD-和CD-ROM" class="headerlink" title="CD 和CD-ROM"></a>CD 和CD-ROM</h3><p>使用高强度激光制作一个母盘</p><p>以母盘为模板压印出复制品</p><p>在凹坑的表面上堵上一层高反射的材料。</p><h3 id="读取方式"><a href="#读取方式" class="headerlink" title="读取方式"></a>读取方式</h3><p>如果激光束照在凹坑（pit）上，由于凹坑表面有些不平，因此光被散 射，反射回低强度的激光</p><p>如果激光束照在台（land）上，台的表面光滑平坦，反射回来的是高 强度的激光</p><p>CD是单螺旋的轨道，轨道上的所有扇区长度相同</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221110163830131.png" alt="image-20221110163830131"></p><p>盘片是变速的，轨道上扇区的长度相同，扇片是变速的（从内圈到外圈，逐渐变慢），凸槽被相同的线速度读出</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优：储存有信息的光盘可以廉价的进行大量的复制，光盘更换方便</p><p>缺点：他是只读的，不能更改，存取时间比磁盘存储器长得多</p><h3 id="高清晰光盘"><a href="#高清晰光盘" class="headerlink" title="高清晰光盘"></a>高清晰光盘</h3><p>通过使用更短波长的激光（在蓝-紫光范围），可以实现更高的位密度（数据 凹坑相对更小）</p><h2 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h2><h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><p>介质是柔韧的聚脂膜带，外涂磁性材料</p><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><ul><li>磁带只能顺序读取</li><li>磁盘可以直接读取</li><li><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221110165906398.png" alt="image-20221110165906398"></li></ul><p>上面是蛇型，下面是并行</p><p>便宜，寿命长，适合数据的重型冷备份</p><h2 id="快闪"><a href="#快闪" class="headerlink" title="快闪"></a>快闪</h2><p>快闪存储器（Flash EEPROM）可随机寻址，应用于内部存储。电子可擦除可编程只读存储器</p><p>（内部存储器的名称要记忆，哪种方式擦除，擦除的什么类型）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>磁盘访问各种方法</title>
      <link href="/2023/03/05/%E7%A3%81%E7%9B%98%E8%AE%BF%E9%97%AE%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2023/03/05/%E7%A3%81%E7%9B%98%E8%AE%BF%E9%97%AE%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>名字</th><th>方法</th><th>优点</th><th>缺点</th><th></th><th></th></tr></thead><tbody><tr><td>最短寻道时间优先（Shortest Seek Time First，SSTF）</td><td>按照请求访问磁盘的先后次序进行处理</td><td>公平简单</td><td>如果有大量访问磁盘的任务，且请求访问的磁道很分散，则性 能上很差，寻道时间长</td><td><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111104504638.png" alt="image-20221111104504638"></td><td></td></tr><tr><td>FCFS,先来先服务，First Come First Service</td><td>优先处理起始位置与当前磁头位置最接近的读写任务</td><td>每次的寻道时间最短（局部最优），平均寻道时间缩短</td><td>可能产生饥饿现象，尤其是位于两端的磁道请求</td><td><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111104452460.png" alt="image-20221111104452460"></td><td></td></tr><tr><td>扫描&#x2F;电梯（SCAN）</td><td>总是按照一个方向进行磁盘调度，直到该方向上的边缘，然后改变方向</td><td>性能较好，平均寻道时间短，不会产生饥饿现象</td><td>只有到最边上的磁道才能改变磁头的移动方向，对于各个位置磁 道响应<strong>频率不平均</strong></td><td><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111104538822.png" alt="image-20221111104538822"></td><td></td></tr><tr><td>循环扫描（C-SCAN）</td><td>只有磁头朝某个方向移动时才会响应请求，移动到边缘后立即让磁头返 回起点，返回途中不做任何处理</td><td>与SCAN算法相比，对于各位置磁道的<strong>响应频率平均</strong></td><td>与SCAN算法相比，平均寻道时间更长</td><td><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111104604510.png" alt="image-20221111104604510"></td><td></td></tr><tr><td>LOOK</td><td>SCAN算法的升级，只要磁头移动方向上不再有请求就立即改变磁头的 方向</td><td></td><td></td><td><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111104633311.png" alt="image-20221111104633311"></td><td></td></tr><tr><td>C-LOOK</td><td>C-SCAN算法的改进，只要在磁头移动方向上不再有请求，就立即让磁 头返回起点</td><td></td><td></td><td><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111104645527.png" alt="image-20221111104645527"></td><td></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>存储器总结图像版</title>
      <link href="/2023/03/05/%E5%AD%98%E5%82%A8%E5%99%A8%E6%80%BB%E7%BB%93%E5%9B%BE%E5%83%8F%E7%89%88/"/>
      <url>/2023/03/05/%E5%AD%98%E5%82%A8%E5%99%A8%E6%80%BB%E7%BB%93%E5%9B%BE%E5%83%8F%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>半导体存储器的类型</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111132220833.png" alt="image-20221111132220833"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111133922947.png" alt="image-20221111133356317"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111134022490.png" alt="image-20221111134022490"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221111133753141.png" alt="image-20221111133753141"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2022-11-11每日一题-实现LFU</title>
      <link href="/2023/03/05/2022-11-11%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E5%AE%9E%E7%8E%B0LFU/"/>
      <url>/2023/03/05/2022-11-11%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E5%AE%9E%E7%8E%B0LFU/</url>
      
        <content type="html"><![CDATA[<h1 id="LFU-缓存"><a href="#LFU-缓存" class="headerlink" title="LFU 缓存"></a><a href="https://leetcode.cn/problems/lfu-cache/description/">LFU 缓存</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Hard (44.38%)</td><td align="center">616</td><td align="center">-</td></tr></tbody></table><details style="color: rgb(238, 255, 255); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Tags</strong></summary><p><a href="https://leetcode.com/tag/design" title="https://leetcode.com/tag/design" style="color: var(--vscode-textLink-foreground);"><code style="color: var(--vscode-textLink-foreground); white-space: pre-wrap;"></code></a></p></details><details style="color: rgb(238, 255, 255); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Companies</strong></summary><p><code style="color: var(--vscode-textPreformat-foreground); white-space: pre-wrap;"></code><code style="color: var(--vscode-textPreformat-foreground); white-space: pre-wrap;"></code></p></details><p>请你为 <a href="https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95">最不经常使用（LFU）</a>缓存算法设计并实现数据结构。</p><p>实现 <code>LFUCache</code> 类：</p><ul><li><code>LFUCache(int capacity)</code> - 用数据结构的容量 <code>capacity</code> 初始化对象</li><li><code>int get(int key)</code> - 如果键 <code>key</code> 存在于缓存中，则获取键的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> - 如果键 <code>key</code> 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 <code>capacity</code> 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近最久未使用</strong> 的键。</li></ul><p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 <strong>使用计数器</strong> 。使用计数最小的键是最久未使用的键。</p><p>当一个键首次插入到缓存中时，它的使用计数器被设置为 <code>1</code> (由于 put 操作)。对缓存中的键执行 <code>get</code> 或 <code>put</code> 操作，使用计数器的值将会递增。</p><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;LFUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, null, -1, 3, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">// cnt(x) = 键 x 的使用计数</span><br><span class="line">// cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）</span><br><span class="line">LFUCache lfu = new LFUCache(2);</span><br><span class="line">lfu.put(1, 1);   // cache=[1,_], cnt(1)=1</span><br><span class="line">lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1</span><br><span class="line">lfu.get(1);      // 返回 1</span><br><span class="line">                 // cache=[1,2], cnt(2)=1, cnt(1)=2</span><br><span class="line">lfu.put(3, 3);   // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小</span><br><span class="line">                 // cache=[3,1], cnt(3)=1, cnt(1)=2</span><br><span class="line">lfu.get(2);      // 返回 -1（未找到）</span><br><span class="line">lfu.get(3);      // 返回 3</span><br><span class="line">                 // cache=[3,1], cnt(3)=2, cnt(1)=2</span><br><span class="line">lfu.put(4, 4);   // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用</span><br><span class="line">                 // cache=[4,3], cnt(4)=1, cnt(3)=2</span><br><span class="line">lfu.get(1);      // 返回 -1（未找到）</span><br><span class="line">lfu.get(3);      // 返回 3</span><br><span class="line">                 // cache=[3,4], cnt(4)=1, cnt(3)=3</span><br><span class="line">lfu.get(4);      // 返回 4</span><br><span class="line">                 // cache=[3,4], cnt(4)=2, cnt(3)=3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= capacity &lt;= 104</code></li><li><code>0 &lt;= key &lt;= 105</code></li><li><code>0 &lt;= value &lt;= 109</code></li><li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code> 方法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key, val, freq;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _key, <span class="type">int</span> _val, <span class="type">int</span> _freq) : <span class="built_in">key</span>(_key), <span class="built_in">val</span>(_val), <span class="built_in">freq</span>(_freq) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> minfreq, capacity;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;Node&gt;::iterator&gt; key_table;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;Node&gt;&gt; freq_table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LFUCache</span>(<span class="type">int</span> _capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        minfreq = <span class="number">0</span>;</span><br><span class="line">        capacity = _capacity;</span><br><span class="line">        key_table.<span class="built_in">clear</span>();</span><br><span class="line">        freq_table.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        list&lt;Node&gt;::iterator node = it-&gt;second;</span><br><span class="line">        <span class="type">int</span> val = node-&gt;val, freq = node-&gt;freq;</span><br><span class="line">        freq_table[freq].<span class="built_in">erase</span>(node);</span><br><span class="line">        <span class="comment">// 如果当前链表为空，我们需要在哈希表中删除，且更新minFreq</span></span><br><span class="line">        <span class="keyword">if</span> (freq_table[freq].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            freq_table.<span class="built_in">erase</span>(freq);</span><br><span class="line">            <span class="keyword">if</span> (minfreq == freq)</span><br><span class="line">                minfreq += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入到 freq + 1 中</span></span><br><span class="line">        freq_table[freq + <span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, val, freq + <span class="number">1</span>));</span><br><span class="line">        key_table[key] = freq_table[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 缓存已满，需要进行删除操作</span></span><br><span class="line">            <span class="keyword">if</span> (key_table.<span class="built_in">size</span>() == capacity)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 通过 minFreq 拿到 freq_table[minFreq] 链表的末尾节点</span></span><br><span class="line">                <span class="keyword">auto</span> it2 = freq_table[minfreq].<span class="built_in">back</span>();</span><br><span class="line">                key_table.<span class="built_in">erase</span>(it2.key);</span><br><span class="line">                freq_table[minfreq].<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">if</span> (freq_table[minfreq].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    freq_table.<span class="built_in">erase</span>(minfreq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            freq_table[<span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, <span class="number">1</span>));</span><br><span class="line">            key_table[key] = freq_table[<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">            minfreq = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 与 get 操作基本一致，除了需要更新缓存的值</span></span><br><span class="line">            list&lt;Node&gt;::iterator node = it-&gt;second;</span><br><span class="line">            <span class="type">int</span> freq = node-&gt;freq;</span><br><span class="line">            freq_table[freq].<span class="built_in">erase</span>(node);</span><br><span class="line">            <span class="keyword">if</span> (freq_table[freq].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                freq_table.<span class="built_in">erase</span>(freq);</span><br><span class="line">                <span class="keyword">if</span> (minfreq == freq)</span><br><span class="line">                    minfreq += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            freq_table[freq + <span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, freq + <span class="number">1</span>));</span><br><span class="line">            key_table[key] = freq_table[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这道题要是从链表开始自己实现就吐了，可以看出来STL有多厉害了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>实现LFU，增加注释的代码</title>
      <link href="/2023/03/05/%E5%AE%9E%E7%8E%B0LFU%EF%BC%8C%E5%A2%9E%E5%8A%A0%E6%B3%A8%E9%87%8A%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
      <url>/2023/03/05/%E5%AE%9E%E7%8E%B0LFU%EF%BC%8C%E5%A2%9E%E5%8A%A0%E6%B3%A8%E9%87%8A%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="LFU-缓存"><a href="#LFU-缓存" class="headerlink" title="LFU 缓存"></a><a href="https://leetcode.cn/problems/lfu-cache/description/">LFU 缓存</a></h1><table><thead><tr><th align="center">Category</th><th align="center">Difficulty</th><th align="center">Likes</th><th align="center">Dislikes</th></tr></thead><tbody><tr><td align="center">algorithms</td><td align="center">Hard (44.38%)</td><td align="center">616</td><td align="center">-</td></tr></tbody></table><details style="color: rgb(238, 255, 255); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Tags</strong></summary><p><a href="https://leetcode.com/tag/design" title="https://leetcode.com/tag/design" style="color: var(--vscode-textLink-foreground);"><code style="color: var(--vscode-textLink-foreground); white-space: pre-wrap;"></code></a></p></details><details style="color: rgb(238, 255, 255); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe WPC&quot;, &quot;Segoe UI&quot;, system-ui, Ubuntu, &quot;Droid Sans&quot;, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary><strong>Companies</strong></summary><p><code style="color: var(--vscode-textPreformat-foreground); white-space: pre-wrap;"></code><code style="color: var(--vscode-textPreformat-foreground); white-space: pre-wrap;"></code></p></details><p>请你为 <a href="https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95">最不经常使用（LFU）</a>缓存算法设计并实现数据结构。</p><p>实现 <code>LFUCache</code> 类：</p><ul><li><code>LFUCache(int capacity)</code> - 用数据结构的容量 <code>capacity</code> 初始化对象</li><li><code>int get(int key)</code> - 如果键 <code>key</code> 存在于缓存中，则获取键的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> - 如果键 <code>key</code> 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 <code>capacity</code> 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近最久未使用</strong> 的键。</li></ul><p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 <strong>使用计数器</strong> 。使用计数最小的键是最久未使用的键。</p><p>当一个键首次插入到缓存中时，它的使用计数器被设置为 <code>1</code> (由于 put 操作)。对缓存中的键执行 <code>get</code> 或 <code>put</code> 操作，使用计数器的值将会递增。</p><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;LFUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, null, -1, 3, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">// cnt(x) = 键 x 的使用计数</span><br><span class="line">// cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）</span><br><span class="line">LFUCache lfu = new LFUCache(2);</span><br><span class="line">lfu.put(1, 1);   // cache=[1,_], cnt(1)=1</span><br><span class="line">lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1</span><br><span class="line">lfu.get(1);      // 返回 1</span><br><span class="line">                 // cache=[1,2], cnt(2)=1, cnt(1)=2</span><br><span class="line">lfu.put(3, 3);   // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小</span><br><span class="line">                 // cache=[3,1], cnt(3)=1, cnt(1)=2</span><br><span class="line">lfu.get(2);      // 返回 -1（未找到）</span><br><span class="line">lfu.get(3);      // 返回 3</span><br><span class="line">                 // cache=[3,1], cnt(3)=2, cnt(1)=2</span><br><span class="line">lfu.put(4, 4);   // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用</span><br><span class="line">                 // cache=[4,3], cnt(4)=1, cnt(3)=2</span><br><span class="line">lfu.get(1);      // 返回 -1（未找到）</span><br><span class="line">lfu.get(3);      // 返回 3</span><br><span class="line">                 // cache=[3,4], cnt(4)=1, cnt(3)=3</span><br><span class="line">lfu.get(4);      // 返回 4</span><br><span class="line">                 // cache=[3,4], cnt(4)=2, cnt(3)=3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= capacity &lt;= 104</code></li><li><code>0 &lt;= key &lt;= 105</code></li><li><code>0 &lt;= value &lt;= 109</code></li><li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code> 方法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key, val, freq;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _key, <span class="type">int</span> _val, <span class="type">int</span> _freq) : <span class="built_in">key</span>(_key), <span class="built_in">val</span>(_val), <span class="built_in">freq</span>(_freq) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> minfreq, capacity;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;Node&gt;::iterator&gt; key_table;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;Node&gt;&gt; freq_table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LFUCache</span>(<span class="type">int</span> _capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        minfreq = <span class="number">0</span>;</span><br><span class="line">        capacity = _capacity;</span><br><span class="line">        key_table.<span class="built_in">clear</span>();</span><br><span class="line">        freq_table.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        list&lt;Node&gt;::iterator node = it-&gt;second;</span><br><span class="line">        <span class="type">int</span> val = node-&gt;val, freq = node-&gt;freq;</span><br><span class="line">        freq_table[freq].<span class="built_in">erase</span>(node);</span><br><span class="line">        <span class="comment">// 如果当前链表为空，我们需要在哈希表中删除，且更新minFreq</span></span><br><span class="line">        <span class="keyword">if</span> (freq_table[freq].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            freq_table.<span class="built_in">erase</span>(freq);</span><br><span class="line">            <span class="keyword">if</span> (minfreq == freq)</span><br><span class="line">                minfreq += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入到 freq + 1 中</span></span><br><span class="line">        freq_table[freq + <span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, val, freq + <span class="number">1</span>));</span><br><span class="line">        key_table[key] = freq_table[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 缓存已满，需要进行删除操作</span></span><br><span class="line">            <span class="keyword">if</span> (key_table.<span class="built_in">size</span>() == capacity)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 通过 minFreq 拿到 freq_table[minFreq] 链表的末尾节点</span></span><br><span class="line">                <span class="keyword">auto</span> it2 = freq_table[minfreq].<span class="built_in">back</span>();</span><br><span class="line">                key_table.<span class="built_in">erase</span>(it2.key);</span><br><span class="line">                freq_table[minfreq].<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">if</span> (freq_table[minfreq].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    freq_table.<span class="built_in">erase</span>(minfreq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            freq_table[<span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, <span class="number">1</span>));</span><br><span class="line">            key_table[key] = freq_table[<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">            minfreq = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 与 get 操作基本一致，除了需要更新缓存的值</span></span><br><span class="line">            list&lt;Node&gt;::iterator node = it-&gt;second;</span><br><span class="line">            <span class="type">int</span> freq = node-&gt;freq;</span><br><span class="line">            freq_table[freq].<span class="built_in">erase</span>(node);</span><br><span class="line">            <span class="keyword">if</span> (freq_table[freq].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                freq_table.<span class="built_in">erase</span>(freq);</span><br><span class="line">                <span class="keyword">if</span> (minfreq == freq)</span><br><span class="line">                    minfreq += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            freq_table[freq + <span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, freq + <span class="number">1</span>));</span><br><span class="line">            key_table[key] = freq_table[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这道题要是从链表开始自己实现就吐了，可以看出来STL有多厉害了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;header.h&quot;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=460 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [460] LFU 缓存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.cn/problems/lfu-cache/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * algorithms</span></span><br><span class="line"><span class="comment"> * Hard (44.38%)</span></span><br><span class="line"><span class="comment"> * Likes:    616</span></span><br><span class="line"><span class="comment"> * Dislikes: 0</span></span><br><span class="line"><span class="comment"> * Total Accepted:    57.9K</span></span><br><span class="line"><span class="comment"> * Total Submissions: 130.5K</span></span><br><span class="line"><span class="comment"> * Testcase Example:</span></span><br><span class="line"><span class="comment"> * &#x27;[&quot;LFUCache&quot;,&quot;put&quot;,&quot;put&quot;,&quot;get&quot;,&quot;put&quot;,&quot;get&quot;,&quot;get&quot;,&quot;put&quot;,&quot;get&quot;,&quot;get&quot;,&quot;get&quot;]\n[[2],[1,1],[2,2],[1],[3,3],[2],[3],[4,4],[1],[3],[4]]&#x27;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实现 LFUCache 类：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象</span></span><br><span class="line"><span class="comment"> * int get(int key) - 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 。</span></span><br><span class="line"><span class="comment"> * void put(int key, int value) - 如果键 key</span></span><br><span class="line"><span class="comment"> * 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 capacity</span></span><br><span class="line"><span class="comment"> * 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除</span></span><br><span class="line"><span class="comment"> * 最近最久未使用 的键。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器</span></span><br><span class="line"><span class="comment"> * 。使用计数最小的键是最久未使用的键。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put</span></span><br><span class="line"><span class="comment"> * 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 示例：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 输入：</span></span><br><span class="line"><span class="comment"> * [&quot;LFUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;,</span></span><br><span class="line"><span class="comment"> * &quot;get&quot;]</span></span><br><span class="line"><span class="comment"> * [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]</span></span><br><span class="line"><span class="comment"> * 输出：</span></span><br><span class="line"><span class="comment"> * [null, null, null, 1, null, -1, 3, null, -1, 3, 4]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 解释：</span></span><br><span class="line"><span class="comment"> * // cnt(x) = 键 x 的使用计数</span></span><br><span class="line"><span class="comment"> * // cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）</span></span><br><span class="line"><span class="comment"> * LFUCache lfu = new LFUCache(2);</span></span><br><span class="line"><span class="comment"> * lfu.put(1, 1);   // cache=[1,_], cnt(1)=1</span></span><br><span class="line"><span class="comment"> * lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1</span></span><br><span class="line"><span class="comment"> * lfu.get(1);      // 返回 1</span></span><br><span class="line"><span class="comment"> * ⁠                // cache=[1,2], cnt(2)=1, cnt(1)=2</span></span><br><span class="line"><span class="comment"> * lfu.put(3, 3);   // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小</span></span><br><span class="line"><span class="comment"> * ⁠                // cache=[3,1], cnt(3)=1, cnt(1)=2</span></span><br><span class="line"><span class="comment"> * lfu.get(2);      // 返回 -1（未找到）</span></span><br><span class="line"><span class="comment"> * lfu.get(3);      // 返回 3</span></span><br><span class="line"><span class="comment"> * ⁠                // cache=[3,1], cnt(3)=2, cnt(1)=2</span></span><br><span class="line"><span class="comment"> * lfu.put(4, 4);   // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用</span></span><br><span class="line"><span class="comment"> * ⁠                // cache=[4,3], cnt(4)=1, cnt(3)=2</span></span><br><span class="line"><span class="comment"> * lfu.get(1);      // 返回 -1（未找到）</span></span><br><span class="line"><span class="comment"> * lfu.get(3);      // 返回 3</span></span><br><span class="line"><span class="comment"> * ⁠                // cache=[3,4], cnt(4)=1, cnt(3)=3</span></span><br><span class="line"><span class="comment"> * lfu.get(4);      // 返回 4</span></span><br><span class="line"><span class="comment"> * ⁠                // cache=[3,4], cnt(4)=2, cnt(3)=3</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 提示：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0 &lt;= capacity &lt;= 10^4</span></span><br><span class="line"><span class="comment"> * 0 &lt;= key &lt;= 10^5</span></span><br><span class="line"><span class="comment"> * 0 &lt;= value &lt;= 10^9</span></span><br><span class="line"><span class="comment"> * 最多调用 2 * 10^5 次 get 和 put 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">// 缓存的节点信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key, val, freq;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _key, <span class="type">int</span> _val, <span class="type">int</span> _freq) : <span class="built_in">key</span>(_key), <span class="built_in">val</span>(_val), <span class="built_in">freq</span>(_freq) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> minfreq, capacity, nowHave;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;Node&gt;::iterator&gt; key_table;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;Node&gt;&gt; freq_table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increaseFreq</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">auto</span> now = it-&gt;second;</span><br><span class="line">        <span class="type">int</span> value = now-&gt;val;</span><br><span class="line">        <span class="type">int</span> freq = now-&gt;freq;</span><br><span class="line">        freq_table[freq].<span class="built_in">erase</span>(now);</span><br><span class="line">        <span class="keyword">if</span> (freq_table[freq].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (minfreq == freq)</span><br><span class="line">                minfreq++;</span><br><span class="line">        &#125;</span><br><span class="line">        freq_table[freq + <span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, freq + <span class="number">1</span>));</span><br><span class="line">        key_table[key] = freq_table[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LFUCache</span>(<span class="type">int</span> _capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        minfreq = <span class="number">0</span>;</span><br><span class="line">        nowHave = <span class="number">0</span>;</span><br><span class="line">        capacity = _capacity;</span><br><span class="line">        key_table.<span class="built_in">clear</span>();</span><br><span class="line">        freq_table.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nowHave == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">increaseFreq</span>(key);</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = key_table.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == key_table.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nowHave &lt; capacity)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// TODO</span></span><br><span class="line">                nowHave++;</span><br><span class="line">                freq_table[<span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, <span class="number">1</span>));</span><br><span class="line">                key_table[key] = freq_table[<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">                minfreq = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// TODO</span></span><br><span class="line">                <span class="comment">//删除使用最小切最近的。</span></span><br><span class="line">                <span class="comment">//删除key上面的，再删去freq——table上面的</span></span><br><span class="line">                <span class="comment">//删去freq_table时候要注意，删除之后其他功能一切正常，例如，要维护最小值（删除的是最小值，且最小值被删完了）</span></span><br><span class="line">                <span class="comment">// freq_table被删完，其实不变成没关系</span></span><br><span class="line">                <span class="comment">//之后添加的时候要维持4个情况，应该是nowhave，minfreq 为1，key-table更新，然后freq_table更新</span></span><br><span class="line">                <span class="keyword">auto</span> now = freq_table[minfreq].<span class="built_in">back</span>();</span><br><span class="line">                key_table.<span class="built_in">erase</span>(now.key);</span><br><span class="line">                freq_table[minfreq].<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">if</span> (freq_table[minfreq].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">                    freq_table.<span class="built_in">erase</span>(minfreq);</span><br><span class="line">                freq_table[<span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, <span class="number">1</span>));</span><br><span class="line">                key_table[key] = freq_table[<span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">                minfreq = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这个和查找的思路一样</span></span><br><span class="line">            <span class="comment">//找到key找到迭代器，用迭代器去访问元素，这个时候要更新freq——table，删去现在的freq，移动到freq+1，同时维护minfreq，minfreq的size变成0了，纪要把minfreq+1。</span></span><br><span class="line">            <span class="keyword">auto</span> now = it-&gt;second;</span><br><span class="line">            <span class="type">int</span> freq = now-&gt;freq;</span><br><span class="line">            freq_table[freq].<span class="built_in">erase</span>(now);</span><br><span class="line">            <span class="keyword">if</span> (freq_table[freq].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (minfreq == freq)</span><br><span class="line">                    minfreq++;</span><br><span class="line">            &#125;</span><br><span class="line">            freq_table[freq + <span class="number">1</span>].<span class="built_in">push_front</span>(<span class="built_in">Node</span>(key, value, freq + <span class="number">1</span>));</span><br><span class="line">            key_table[key] = freq_table[freq + <span class="number">1</span>].<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache* obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">LFUCache <span class="title">lfu</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    lfu.<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// cache=[1,_], cnt(1)=1</span></span><br><span class="line">    lfu.<span class="built_in">put</span>(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// cache=[2,1], cnt(2)=1, cnt(1)=1</span></span><br><span class="line">    lfu.<span class="built_in">get</span>(<span class="number">1</span>);    <span class="comment">// 返回 1</span></span><br><span class="line">                   <span class="comment">// cache=[1,2], cnt(2)=1, cnt(1)=2</span></span><br><span class="line">    lfu.<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">3</span>); <span class="comment">// 去除键 2 ，因为 cnt(2)=1 ，使用计数最小</span></span><br><span class="line">                   <span class="comment">// cache=[3,1], cnt(3)=1, cnt(1)=2</span></span><br><span class="line">    lfu.<span class="built_in">get</span>(<span class="number">2</span>);    <span class="comment">// 返回 -1（未找到）</span></span><br><span class="line">    lfu.<span class="built_in">get</span>(<span class="number">3</span>);    <span class="comment">// 返回 3</span></span><br><span class="line">                   <span class="comment">// cache=[3,1], cnt(3)=2, cnt(1)=2</span></span><br><span class="line">    lfu.<span class="built_in">put</span>(<span class="number">4</span>, <span class="number">4</span>); <span class="comment">// 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用</span></span><br><span class="line">                   <span class="comment">// cache=[4,3], cnt(4)=1, cnt(3)=2</span></span><br><span class="line">    lfu.<span class="built_in">get</span>(<span class="number">1</span>);    <span class="comment">// 返回 -1（未找到）</span></span><br><span class="line">    lfu.<span class="built_in">get</span>(<span class="number">3</span>);    <span class="comment">// 返回 3</span></span><br><span class="line">                   <span class="comment">// cache=[3,4], cnt(4)=1, cnt(3)=3</span></span><br><span class="line">    lfu.<span class="built_in">get</span>(<span class="number">4</span>);    <span class="comment">// 返回 4</span></span><br><span class="line">                   <span class="comment">// cache=[3,4], cnt(4)=2, cnt(3)=3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DRAM的刷新方式</title>
      <link href="/2023/03/05/DRAM%E7%9A%84%E5%88%B7%E6%96%B0%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/03/05/DRAM%E7%9A%84%E5%88%B7%E6%96%B0%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="DRAM的刷新方式"><a href="#DRAM的刷新方式" class="headerlink" title="DRAM的刷新方式"></a>DRAM的刷新方式</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>刷新一行的时间等于存储周期</p><p>刷新周期：从对整个存储器刷新结束时起，到对整个DRAM全部刷新一遍为止时间间隔。</p><p>刷新信号周期：相邻两行位元之间刷新的时间间隔单元。</p><p>刷新间隔时间：每单元刷新间隔的时间，</p><p>刷新行数：单个芯片的单个矩阵的行数。</p><p>刷新方式：集中式刷新、分散式刷新和异步式刷新。</p><h2 id="集中式刷新"><a href="#集中式刷新" class="headerlink" title="集中式刷新"></a>集中式刷新</h2><p>64K×1位DRAM芯片中，存储电路由4个独立的128×128的存储矩阵组成。</p><p>设存储器存储周期为500ns，单元刷新间隔是64ms。</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/v2-06204ed2d7fdfaed5ca2397c0461ae2d_r.jpg" alt="img"></p><p>集中对128行刷新一遍所需时间128×500ns&#x3D;64us</p><p>存储周期*行数&#x3D;内部刷新时间&#x3D;死时间</p><h2 id="分散式刷新"><a href="#分散式刷新" class="headerlink" title="分散式刷新"></a>分散式刷新</h2><p><img src="https://pic3.zhimg.com/80/v2-726c97812b5e3d75d19e37d2251fc20a_720w.webp" alt="img"></p><p>在任何一个存储周期内，分为访存和刷新两个子周期。</p><blockquote><p>访存时间内，供CPU和其他主设备访问<br>在刷新时间内，对DRAM的某一行刷新</p></blockquote><p>系统存储周期为存储器存储周期的两倍</p><p>刷新周期缩短，为 128×1μs&#x3D;128μs，2x存储器存储x周期行数</p><p>但是：在2ms的单元刷新间隔时间内，对DRAM刷新了 2ms÷128μs&#x3D;15 遍。</p><h3 id="异步刷新"><a href="#异步刷新" class="headerlink" title="异步刷新"></a>异步刷新</h3><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/v2-91d15c8110c27bf1bb095e84e03a0fd7_r.jpg" alt="img"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/v2-ac6d8b729e54e9fecb6229e72cfb9629_r.jpg" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cache大题目做法</title>
      <link href="/2023/03/05/cache%E5%A4%A7%E9%A2%98%E7%9B%AE%E5%81%9A%E6%B3%95/"/>
      <url>/2023/03/05/cache%E5%A4%A7%E9%A2%98%E7%9B%AE%E5%81%9A%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Cache的大题目"><a href="#Cache的大题目" class="headerlink" title="Cache的大题目"></a>Cache的大题目</h2><p>主存容量，字长，块大小，cache容量，求直接映射，全相连映射，组相连映射的格式</p><p>1.主存容量可以得到地址的总位数</p><p>2.cache的容量除以一行的容量得到cache有多少行，直接映射，就是行号，组相连映射除以路数就是组号</p><p>3.无论那种，行内地址的长度和是log一行的容量</p><h2 id="Cache的结构"><a href="#Cache的结构" class="headerlink" title="Cache的结构"></a>Cache的结构</h2><p>标记项（有效位（1位），标记位（同地址的标记位），控制修改位，替换错误位），数据位（cache的内容，行大小）</p><h2 id="直接映射求一个地址在cache的存取的行号"><a href="#直接映射求一个地址在cache的存取的行号" class="headerlink" title="直接映射求一个地址在cache的存取的行号"></a>直接映射求一个地址在cache的存取的行号</h2><p>把地址写成二进制的形式，然后对应直接映射的内存的格式。</p><p>数组如何求地址，计算地址<br>$$<br>&amp;a[x]&#x3D;a+x*T_{a的数据类型的长度站多少字节(按字符寻址)}<br>$$<br>地址除以行的元素数量，在mod行数可以得到，直接映射到哪一行。</p><p>或者，计算地址，除以一行的容量（向下取整 ），结果mod一个cache有多少块</p><h2 id="求命中率，效率，访问时间"><a href="#求命中率，效率，访问时间" class="headerlink" title="求命中率，效率，访问时间"></a>求命中率，效率，访问时间</h2><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>$$<br>h_{命中率}&#x3D;\frac{N_c}{N_c+N_m}<br>$$</p><p>$$<br>t_a&#x3D;ht_c+(1-h)ta<br>$$</p><p>$$<br>e&#x3D;\frac{t_c}{t_a}<br>$$</p><h3 id="算命中情况"><a href="#算命中情况" class="headerlink" title="算命中情况"></a>算命中情况</h3><p>访问线性的元素，访问一个cache没有的元素的时候，cache的一整行都会放进去，那么以后的元素就不用担心了。</p><h2 id="LRU，FIFO算法"><a href="#LRU，FIFO算法" class="headerlink" title="LRU，FIFO算法"></a>LRU，FIFO算法</h2><h3 id="该算法分析命中率"><a href="#该算法分析命中率" class="headerlink" title="该算法分析命中率"></a>该算法分析命中率</h3><p>对于循环，首先分析第一次循环（可以求访问主存的次数然后求减法）。</p><p>对于后面的循环，可以想象成遍历的每一行在每一组里面轮流的放，如果满了就替换，如果有不放。</p><p>思考问题的时候，要把<code>遍历的每一行在每一组里面轮流的放</code>这个事件全部想象一遍。</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><blockquote><p>适用的情况，把cache的是盛放快的容器，对于不断放入的快，使用最少的替换（最小的单位是块）</p></blockquote><h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p>主存中12345映射到一个组里面，主存访问顺序{1,2,3,4,1,2,5,1,2,3,4,5}</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221113201339274.png" alt="image-20221113201339274"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221113201345483.png" alt="image-20221113201345483"></p><p>LRU算法实际上就是一个队列，删去队列，每次队列人数满了的时候就删去出队，然后进队，再写表的时候保证就改一个位置的值，</p><p>FIFO算法实际上就是一个队列，，不同的是，当队列里面有这个元素的时候，不操作，（LRU会把那个元素移动到末尾）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>堆模板+vscode调试技巧</title>
      <link href="/2023/03/05/%E5%A0%86%E6%A8%A1%E6%9D%BF+vscode%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
      <url>/2023/03/05/%E5%A0%86%E6%A8%A1%E6%9D%BF+vscode%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="【模板】堆"><a href="#【模板】堆" class="headerlink" title="【模板】堆"></a>【模板】堆</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数列，初始为空，请支持下面三种操作：</p><ol><li>给定一个整数 $x$，请将 $x$ 加入到数列中。</li><li>输出数列中最小的数。</li><li>删除数列中最小的数（如果有多个数最小，只删除 $1$ 个）。</li></ol><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是一个整数，表示操作的次数 $n$。<br>接下来 $n$ 行，每行表示一次操作。每行首先有一个整数 $op$ 表示操作类型。</p><ul><li>若 $op &#x3D; 1$，则后面有一个整数 $x$，表示要将 $x$ 加入数列。</li><li>若 $op &#x3D; 2$，则表示要求输出数列中的最小数。</li><li>若 $op &#x3D; 3$，则表示删除数列中的最小数。如果有多个数最小，只删除 $1$ 个。</li></ul><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每个操作 $2$，输出一行一个整数表示答案。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">1 5</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p><strong>【数据规模与约定】</strong></p><ul><li>对于 $30%$ 的数据，保证 $n \leq 15$。</li><li>对于 $70%$ 的数据，保证 $n \leq 10^4$。</li><li>对于 $100%$ 的数据，保证 $1 \leq n \leq 10^6$，$1 \leq x \lt 2^{31}$，$op \in {1, 2, 3}$。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">minHeap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *heap;</span><br><span class="line">    <span class="type">int</span> maxSize;</span><br><span class="line">    <span class="type">int</span> nowSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">minHeap</span>(<span class="type">int</span> _maxSize);</span><br><span class="line">    ~<span class="built_in">minHeap</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(nowSize != maxSize);</span><br><span class="line">        nowSize++;</span><br><span class="line">        heap[nowSize] = value;</span><br><span class="line">        <span class="type">int</span> index = nowSize;</span><br><span class="line">        <span class="keyword">while</span> (index / <span class="number">2</span> != <span class="number">0</span> &amp;&amp; value &lt; heap[index / <span class="number">2</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            heap[index] = heap[index / <span class="number">2</span>];</span><br><span class="line">            index = index / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        heap[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(nowSize != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(nowSize != <span class="number">0</span>);</span><br><span class="line">        T y = heap[nowSize--];</span><br><span class="line">        <span class="type">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> child = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (child &lt;= nowSize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (child + <span class="number">1</span> &lt;= nowSize &amp;&amp; heap[child] &gt; heap[child + <span class="number">1</span>])</span><br><span class="line">                child = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (heap[child] &gt; y)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            heap[index] = heap[child];</span><br><span class="line">            index = child;</span><br><span class="line">            child = index * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        heap[index] = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">minHeap&lt;T&gt;::<span class="built_in">minHeap</span>(<span class="type">int</span> _maxSize)</span><br><span class="line">&#123;</span><br><span class="line">    maxSize = _maxSize;</span><br><span class="line">    nowSize = <span class="number">0</span>;</span><br><span class="line">    heap = <span class="keyword">new</span> T[maxSize + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">minHeap&lt;T&gt;::~<span class="built_in">minHeap</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] heap;</span><br><span class="line">    heap = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">minHeap&lt;<span class="type">int</span>&gt; <span class="title">heap</span><span class="params">(<span class="number">1000000</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cmd;</span><br><span class="line">        cin &gt;&gt; cmd;</span><br><span class="line">        <span class="keyword">if</span> (cmd == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            heap.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(heap.<span class="built_in">top</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : ans)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关键步骤：上浮</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> index = nowSize;</span><br><span class="line">       <span class="keyword">while</span> (index / <span class="number">2</span> != <span class="number">0</span> &amp;&amp; value &lt; heap[index / <span class="number">2</span>])</span><br><span class="line">       &#123;</span><br><span class="line">           heap[index] = heap[index / <span class="number">2</span>];</span><br><span class="line">           index = index / <span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       heap[index] = value;</span><br></pre></td></tr></table></figure><p>index从nowSize开始，慢慢上浮</p><p>关键步骤：下沉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">T y = heap[nowSize--];</span><br><span class="line">        <span class="type">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> child = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (child &lt;= nowSize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (child + <span class="number">1</span> &lt;= nowSize &amp;&amp; heap[child] &gt; heap[child + <span class="number">1</span>])</span><br><span class="line">                child = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (heap[child] &gt; y)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            heap[index] = heap[child];</span><br><span class="line">            index = child;</span><br><span class="line">            child = index * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        heap[index] = y;</span><br></pre></td></tr></table></figure><p>index和child2个变量，nowSize会缩小，前提条件是nowSize会缩小</p><h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221118214739359.png" alt="image-20221118214739359"></p><p><code>*(int(*)[size])heap</code>,添加这个监事变量可以观察数组。</p><h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><p>GDB产生错误的时候，要几个把TERMINAL的输入全部删了，防止下一次出错</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言到汇编语言</title>
      <link href="/2023/03/05/C%E8%AF%AD%E8%A8%80%E5%88%B0%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
      <url>/2023/03/05/C%E8%AF%AD%E8%A8%80%E5%88%B0%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="z-x3D-z-y"><a href="#z-x3D-z-y" class="headerlink" title="z&#x3D;z*y"></a>z&#x3D;z*y</h2><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221122221355844.png" alt="image-20221122221355844"></p><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>首先有一个作为临时存储器</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221122221536945.png" alt="image-20221122221536945"></p><p>seqi+beqz（not true）+addi</p><h2 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h2><p>seqi+beqz+—+j （done）else  </p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221122222026484.png" alt="image-20221122222026484"></p><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221122222044972.png" alt="image-20221122222044972"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2023/03/05/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2023/03/05/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="并查集用处"><a href="#并查集用处" class="headerlink" title="并查集用处"></a>并查集用处</h2><ol><li>判断图里面有没有环</li></ol><iframe src="//player.bilibili.com/player.html?aid=38498175&bvid=BV13t411v7Fs&cid=67672061&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="算法的实现"><a href="#算法的实现" class="headerlink" title="算法的实现"></a>算法的实现</h2><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>一维数组实现一棵树</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221123110713993.png" alt="image-20221123110713993"></p><p>parent[i]表示i的父亲，具体连接方式是把跟节点连接起来，也就是有同一个父亲就表示是在同一个并查集里面</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟存储器补充</title>
      <link href="/2023/03/05/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E8%A1%A5%E5%85%85/"/>
      <url>/2023/03/05/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<h1 id="页的一些知识点"><a href="#页的一些知识点" class="headerlink" title="页的一些知识点"></a>页的一些知识点</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="页框"><a href="#页框" class="headerlink" title="页框"></a>页框</h3><p>来自内存，内存空间划分为大小相同的分区</p><h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><p>来自用户的进程，把用户的进程的地址空间划分为相同的区域</p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>建立，虚拟地址和物理地址的映射关系（主要是页面的映射，页面，到页框）</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>每一行是也该虚拟地址的页，包含虚拟地址的页号（不用再行里面表示，页表的行号就是虚拟地址的页号），和物理地址的块号，（每一行的长度就是物理地址的块号，加上一些标记位）</p><blockquote><p>假设一个分页虚拟存储系统的虚拟地址为40位，物理地址为36位，页大小为16KB，按字节编址。若页表中的有效位、存储保护位、修改位、使用位共占4位，磁盘地址不在页表中。则该存储系统中每个程序的页表大小为多少（单位：MB）？（说明：1.假设每个程序都能使用全部的虚拟内存；2.页表项的长度必须为字节的整数倍）</p></blockquote><p>公式：虚拟地址的页数*（物理地址页数的位数+标记位）</p><h3 id="TBL"><a href="#TBL" class="headerlink" title="TBL"></a>TBL</h3><p>1.CPU首先得到的是虚拟地址，必须将虚拟地址转换为物理地址才能进行数据访问。这个过程先查TLB，若TLB命中，则得到了物理地址，进行步骤2；否则，继续查找主存中的页表。若仍不命中，则引发缺页中断进行调页。调页过程又可能引发驻留集页替换和页回写过程。</p><p>2.得到物理地址之后，首先访问cache，若命中，CPU直接从cache中读取相应物理地址中的内容；若不命中，则访问主存读取数据，并且更新cache，此过程又可能引发cache的行替换和回写过程。</p><h4 id="具体做题"><a href="#具体做题" class="headerlink" title="具体做题"></a>具体做题</h4><p>首先分析，各个地址的位数的分布，</p><p>虚拟地址：页面号+页内地址</p><p>物理地址：页框号+页内地址</p><p>虚拟地址的页面号：TLB标记+具体是第几组（组号）</p><p>物理地址 ：标记+具体是第几组（组号）+行（块）内地址</p><blockquote><p>假设一个计算机系统中有一个TLB和一个L1 data cache。该系统按字节编址，虚拟地址16位，物理地址12位；页大小为128B，TLB为4-路组相连，共有16个页表项；L1 data cache采用直接映射方式，块大小为4B，共16行。在系统运行的某一时刻，TLB、页表和L1 data cache中的部分内容如下图所示（16进制表示）：</p><p>请问：</p><p>a) 虚拟地址中哪几位表示虚拟页号？</p><p>b) 虚拟页号的哪几位表示TLB标记？ </p><p>c) 物理地址中哪几位表示物理页号？ </p><p>d) 在访问cache时，物理地址哪几位表示行号？</p><p>e) CPU从地址067AH中取出的值为多少？<img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221126104823366.png" alt="image-20221126104823366"></p></blockquote><p>虚拟地址的页数前9位，</p><p>虚拟页号的7位是标记，后买2位是组号（查找要扫描组里面的全部）</p><p>物理地址前5位是页号</p><p>cache的前6位是标记，4位是块号，2位块内标记</p><p>067A&#x3D;0000 0110 0111 1010</p><p>虚拟页号是0000 001100 &#x3D;0C，先查TBL，先组号对上，然后看标记是否一样，没有03，查找页表，页框号是19</p><p>110011 1110 10</p><p>cache里面先查组号，是E，然后看标记为是一样的33，然后块内标记是10 于是4A</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自陷例程和中断</title>
      <link href="/2023/03/05/%E8%87%AA%E9%99%B7%E4%BE%8B%E7%A8%8B%E5%92%8C%E4%B8%AD%E6%96%AD/"/>
      <url>/2023/03/05/%E8%87%AA%E9%99%B7%E4%BE%8B%E7%A8%8B%E5%92%8C%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="自陷例程序和中断"><a href="#自陷例程序和中断" class="headerlink" title="自陷例程序和中断"></a>自陷例程序和中断</h1><h2 id="造成混乱的情况"><a href="#造成混乱的情况" class="headerlink" title="造成混乱的情况"></a>造成混乱的情况</h2><p>I&#x2F;O行为包含很多被程序所共享的设备寄存器的使用，用户程序员没有谨慎处理，给其他用户程序造成混乱</p><h2 id="特权"><a href="#特权" class="headerlink" title="特权"></a>特权</h2><p>硬件寄存器是有特权的，不拥有适当的特权级别的程序不能被访问</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>自陷（TRAP）指令</p><p>操作系统</p><p>拥有适当的特权级别</p><p>用户程序员不需要在这个层面上理解I&#x2F;O</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221129202838290.png" alt="image-20221129202838290"></p><h2 id="TRAP机制"><a href="#TRAP机制" class="headerlink" title="TRAP机制"></a>TRAP机制</h2><h3 id="服务例程"><a href="#服务例程" class="headerlink" title="服务例程"></a>服务例程</h3><p>操作系统的一部分，表示用户程序执行的一组程序</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221129203114948.png" alt="image-20221129203114948"></p><h3 id="TRAP向量表"><a href="#TRAP向量表" class="headerlink" title="TRAP向量表"></a>TRAP向量表</h3><p>包括了256个服务例程的起始地址的表，每一个起始地址需要占用4个连续的存储单元</p><p>256个服务例程需要使用256*4个单元，这张表被存储在存储单元的x0000 0000到x0000 03FF中。</p><h4 id="数据区-x2F-代码区"><a href="#数据区-x2F-代码区" class="headerlink" title="数据区&#x2F;代码区"></a>数据区&#x2F;代码区</h4><p>数据区的起始位置地址：代码区起始地址之前的x100个单元</p><h2 id="TRAP指令"><a href="#TRAP指令" class="headerlink" title="TRAP指令"></a>TRAP指令</h2><p>操作系统代表用户程序执行某一个服务例程，然后把控制权交给用户程序</p><p>根据TRAP向量，PC&lt;-相应服务例程首地址</p><p>提供返回路径&#x2F;“链接”</p><h4 id="指令阶段-1"><a href="#指令阶段-1" class="headerlink" title="指令阶段-1"></a>指令阶段-1</h4><p>取指令</p><p>pc&lt;-pc+4</p><p>译码；</p><p>计算有效地址；</p><p>​TRAP向量扩展到32位，然后左移2位（相当于x4）</p><p>访问内存</p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221129204306357.png" alt="image-20221129204306357" style="zoom: 50%;" /><p>写回</p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221129204318563.png" alt="image-20221129204318563" style="zoom:50%;" /><p>TRAP服务例程执行结束</p><p>在TRAP服务例程的最后执行一条JR R31的指令，控制就可以返回到用户程序的正确位置</p><h4 id="键盘输入服务例程（TRAP-X06）（GETC）"><a href="#键盘输入服务例程（TRAP-X06）（GETC）" class="headerlink" title="键盘输入服务例程（TRAP X06）（GETC）"></a>键盘输入服务例程（TRAP X06）（GETC）</h4><h4 id="字符输出服务例程（TRAP-X07）（PUT）"><a href="#字符输出服务例程（TRAP-X07）（PUT）" class="headerlink" title="字符输出服务例程（TRAP X07）（PUT）"></a>字符输出服务例程（TRAP X07）（PUT）</h4><h4 id="字符串输出服务例程（TRAP-X08）（OUT）"><a href="#字符串输出服务例程（TRAP-X08）（OUT）" class="headerlink" title="字符串输出服务例程（TRAP X08）（OUT）"></a>字符串输出服务例程（TRAP X08）（OUT）</h4><h4 id="字符输入服务例程（TRAP-X08）（IN）回显到显示器上"><a href="#字符输入服务例程（TRAP-X08）（IN）回显到显示器上" class="headerlink" title="字符输入服务例程（TRAP X08）（IN）回显到显示器上"></a>字符输入服务例程（TRAP X08）（IN）回显到显示器上</h4><h4 id="字符串输入服务例程（TRAP-X0A）（GETS）"><a href="#字符串输入服务例程（TRAP-X0A）（GETS）" class="headerlink" title="字符串输入服务例程（TRAP X0A）（GETS）"></a>字符串输入服务例程（TRAP X0A）（GETS）</h4><h3 id="寄存器的保存与恢复"><a href="#寄存器的保存与恢复" class="headerlink" title="寄存器的保存与恢复"></a>寄存器的保存与恢复</h3><p>如果一个 寄存器内的值在该寄存器被存储其他值之后再次被用到，必须在其他事情发生之前将其保存，再次使用它之前将其恢复</p><h3 id="被调用者保存"><a href="#被调用者保存" class="headerlink" title="被调用者保存"></a>被调用者保存</h3><p>callee-save（键盘输入输出）</p><p>由被用户程序调用的服务例程完成寄存器的保护与恢复。</p><p>被调用的程序需要知道需要使用那些寄存器，而调用者不知道哪些寄存器的值将会被破坏</p><p>caller-save</p><p>由调用程序完成寄存器的保存与恢复</p><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>如果那些程序知道那些寄存器会被接下来的操作所破坏，处理保存&#x2F;恢复问题应该由那些程序保存。</p><p>小总结</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221129211805724.png" alt="image-20221129211805724"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221129212113509.png" alt="image-20221129212107023"></p><h2 id="中断驱动的IO"><a href="#中断驱动的IO" class="headerlink" title="中断驱动的IO"></a>中断驱动的IO</h2><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221129212553484.png" alt="image-20221129212553484"></p><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221129212612157.png" alt="image-20221129212612157"></p><h2 id="中断信号的产生"><a href="#中断信号的产生" class="headerlink" title="中断信号的产生"></a>中断信号的产生</h2><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221129213352053.png" alt="image-20221129213352053"></p><p>就绪位和中断允许位</p><h2 id="INT信号（看书，书上详细）"><a href="#INT信号（看书，书上详细）" class="headerlink" title="INT信号（看书，书上详细）"></a>INT信号（看书，书上详细）</h2><p>中断请求信号（Interrupt Reqest，IRQ）</p><p>IE位（中断允许位）和就绪位的逻辑与</p><p>各个中断设备发出的IRQ信号经过或门，产生INT信号</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221129213620462.png" alt="image-20221129213620462"></p><h3 id="KBDR、KBSR寄存器"><a href="#KBDR、KBSR寄存器" class="headerlink" title="KBDR、KBSR寄存器"></a>KBDR、KBSR寄存器</h3><p>KBDR，键盘数据寄存器0到7位庸才存储输入字符的ASCII码</p><p>KBSR，键盘状态寄存器，第15位用来存储同步信息（控制处理器和键盘的同步）</p><h3 id="DDR，DSR寄存器"><a href="#DDR，DSR寄存器" class="headerlink" title="DDR，DSR寄存器"></a>DDR，DSR寄存器</h3><p>DDR输出数据寄存器，DDR【7:0】的存储输出字符的ASCII码，DSR的15位用来同步信息</p><p>DSR输出状态寄存器</p><h3 id="CAUSE：原因寄存器"><a href="#CAUSE：原因寄存器" class="headerlink" title="CAUSE：原因寄存器"></a>CAUSE：原因寄存器</h3><p>某个设备发出IRQ信号，就会在原因寄存器的相应位置上设为1</p><p>原因寄存器是一个特殊寄存器，只有在特权模式下才可以访问，</p><p>CAUSE【15:8】为中断未决位</p><h2 id="测试INT信号"><a href="#测试INT信号" class="headerlink" title="测试INT信号"></a>测试INT信号</h2><p>处理器对INT信号的处理</p><blockquote><p>原来的指令的执行模式：取指令，译码，执行，访问内存和写回5个阶段</p></blockquote><p>为测试中断信号而增加的逻辑</p><p>写回并检测INT信号</p><p>INT为0，表示没有中断，和往常一样返回到取指令阶段</p><p>INT为1，保存并改变抽象的状态，PC加载到x8000 1000执行操作系统的中断服务例程，处理该信号发出的中断请求。</p><h2 id="保存以及改变程序状态"><a href="#保存以及改变程序状态" class="headerlink" title="保存以及改变程序状态"></a>保存以及改变程序状态</h2><p>在进入中断程序之前，（PC加载到x8000 1000之前）</p><p>保存足够的正在运行的程序的状态信息，以便I&#x2F;O设备请求被满足之后，能够返回被中断的程序</p><p>改变程序状态，以便访问恰当的资源，以及避免各种I&#x2F;O设备相互干扰</p><h2 id="程序状态"><a href="#程序状态" class="headerlink" title="程序状态"></a>程序状态</h2><p>作为程序一部分的存储单元的内容</p><p>所有通用寄存器的内容</p><p>寄存器：PC和SR</p><h2 id="PC和EPC"><a href="#PC和EPC" class="headerlink" title="PC和EPC"></a>PC和EPC</h2><p>pc存取下一跳要执行的指令的地址，必须要保持下来，以便当被中断的程序重新执行时，可以回到下一跳指令地址</p><p>DLC中有特殊寄存器EPC用来保存中断发生时的PC中的值。、</p><h2 id="SR"><a href="#SR" class="headerlink" title="SR"></a>SR</h2><h4 id="SR【0】"><a href="#SR【0】" class="headerlink" title="SR【0】"></a>SR【0】</h4><p>表示程序是否可以被I&#x2F;O设备中断，应该被保存(程序到中断服务进程之后会把SR【0】设置为0，表示程序不能被中断程序中断，之后要改回去)</p><p>SR【1】</p><p>表示正在运行的程序是处于特权还是非特权模式</p><h3 id="中断优先级（这地方看书比较清楚）"><a href="#中断优先级（这地方看书比较清楚）" class="headerlink" title="中断优先级（这地方看书比较清楚）"></a>中断优先级（这地方看书比较清楚）</h3><p>DLX有6个硬件优先级，PL0，——-PL5</p><ul><li>数字越高，优先级越高</li><li>I&#x2F;O的速度越快优先级越高</li></ul><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/IMG_20221129_224739.jpg" alt="IMG_20221129_224739"></p><p>+<img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/IMG_20221129_224748.jpg" alt="IMG_20221129_224739"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221129225002234.png" alt="image-20221129225002234"></p><h2 id="从中断中返回"><a href="#从中断中返回" class="headerlink" title="从中断中返回"></a>从中断中返回</h2><p>首先，清空CAUSE寄存器，表示处理完所有中断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DONE： movi2s r0，x0D； 将原因寄存器清空</span><br></pre></td></tr></table></figure><p>然后使用RFE指令</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221129225318275.png" alt="image-20221129225318275"></p><h2 id="中断嵌套"><a href="#中断嵌套" class="headerlink" title="中断嵌套"></a>中断嵌套</h2><p>低优先级的允许被高优先级的设备中断</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221129225552509.png" alt="image-20221129225552509"></p><h2 id="C语言的I-x2F-O"><a href="#C语言的I-x2F-O" class="headerlink" title="C语言的I&#x2F;O"></a>C语言的I&#x2F;O</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>总线有关的计算题</title>
      <link href="/2023/03/05/%E6%80%BB%E7%BA%BF%E6%9C%89%E5%85%B3%E7%9A%84%E8%AE%A1%E7%AE%97%E9%A2%98/"/>
      <url>/2023/03/05/%E6%80%BB%E7%BA%BF%E6%9C%89%E5%85%B3%E7%9A%84%E8%AE%A1%E7%AE%97%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="所求的概念"><a href="#所求的概念" class="headerlink" title="所求的概念"></a>所求的概念</h2><h3 id="总线带宽"><a href="#总线带宽" class="headerlink" title="总线带宽"></a>总线带宽</h3><p>总线最大的数据传输速率（不去考虑总线总裁和地址传输）</p><h3 id="数据传输速率"><a href="#数据传输速率" class="headerlink" title="数据传输速率"></a>数据传输速率</h3><p>考虑地址传输和握手等因素的数据传输速率</p><h3 id="总线事务"><a href="#总线事务" class="headerlink" title="总线事务"></a>总线事务</h3><p>包括传送地址和总线命令，准备数据和数据传输</p><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>空闲间隔每一个总线事务都有</p><p>总线2是分离的32位地址和32位数据的总线。支持最多连续8个字的存储器读操作和写操作总线事务，读操作的过程为：1个时钟周期传送地址，2个时钟周期延迟等待，从第4个时钟周期开始，存储器准备好数据，总线以每个时钟周期一个字的速度传输最多8个字；对于写操作，在第1个时钟周期内第1个数据字和地址一起传输，经过2个时钟周期的等待延迟后，以每个时钟周期1个字的速度传输，最多传输7个余下的数据字。</p><p>假设这两种总线的时钟频率都是100MHz</p><p>连续进行单个字的存储器写操作总线事务，总线2的数据传输率为多少（单位：Mbps）？</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>假定连接主存和CPU之间的同步总线具有以下特性：支持4字块和16字块（字长32位）</p><p>两种长度的块传输，总线时钟频率为200MHz，总线宽度为64位，每个64位数据的传送需要1个时钟周期，向主存发送一个地址需要1个时钟周期，每个总线事务之间有2个空闲时钟周期。若访问主存时最初4个字的存取时间为148ns，随后每读4个字的时间为26ns，则在4字块和16字块两种传输方式下，该总线上传输512个字时的数据传输率分别为多少？</p><p>总线时钟频率为200MHz，因而总线时钟周期为1&#x2F;200M&#x3D;5ns。</p><p>对于4字传送方式，每个总线事务由一个地址传送和一个4字的数据块传送组成。首先，CPU发送地址到主存，需要1个时钟周期；主存读开始的4个字，需要148ns&#x2F;5ns&#x3D;30个时钟周期；然后在总线上传输4个字，需要4×32&#x2F;64&#x3D;2个时钟周期；最后，有2个空闲时钟周期。所以，一次总线事务总共需要1+30+2+2&#x3D;35个时钟周期，512个字需512&#x2F;4&#x3D;128个事务，因而整个传送需35×128&#x3D;4480个时钟周期，得到总延时为4480×5ns&#x3D;22400ns。总线的数据传输率为(512×4B)&#x2F;22400ns&#x3D;731.4Mbps。</p><p>对于16字块传送方式，从第二个4 字开始，每读一个4 字的时间为26ns，相当于26ns&#x2F;5ns&#x3D;6 个时钟周期。一次总线事务总共需要1+30+3×max(6,2)+2+2&#x3D;53个时钟周期，512字需512&#x2F;16&#x3D;32个事务，因而整个传送需53×32&#x3D;1696个时钟周期，总线的数据传输率为(512×4B)&#x2F;(1696×5ns)&#x3D;1932.1Mbps。</p><p>（注意：<strong>这里148ns和26ns不是总线时钟周期的整数倍，主存会先准备好数据，等到下一个总线时钟周期开始时传输数据</strong>。）</p><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><ol><li>这里148ns和26ns不是总线时钟周期的整数倍，主存会先准备好数据，等到下一个总线时钟周期开始时传输数据</li><li>同步总线，的任务顺序<strong>地址传输，数据准备：数据传输 空闲</strong>，看数据准备和数据发送那个快，哪个快就是等谁</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面对对象c++中的继承带来的命名问题</title>
      <link href="/2023/03/05/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1c++%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%91%BD%E5%90%8D%E9%97%AE%E9%A2%98/"/>
      <url>/2023/03/05/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1c++%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%91%BD%E5%90%8D%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="面对对象c-中的继承带来的命名问题"><a href="#面对对象c-中的继承带来的命名问题" class="headerlink" title="面对对象c++中的继承带来的命名问题"></a>面对对象c++中的继承带来的命名问题</h1><blockquote><p>详细见Affectless C++ P156</p></blockquote><ol><li><p>Derived类里面有和Base一样名字的成员函数是重载（ overload），相当于Base的类的成员函数被抹除掉了，调用只能调用Derived里面的。（就算参数不一样也可以）</p></li><li><p>在Derived中使用<code>using Base::mf1</code>可以让mf1在Derived的作用域里面可见，但是这种方式会让Base中的所有的mf1在Derived中都可见，可以使用forwarding function（p161）来解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//in the Class Derived</span><br><span class="line">public:</span><br><span class="line">void mf1()&#123;</span><br><span class="line">Base::mf1();//Derived private 继承 Base</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>The application of the inheritance of interface and the inheritance of implementation</title>
      <link href="/2023/03/05/The%20application%20of%20the%20inheritance%20of%20interface%20and%20the%20inheritance%20of%20implementation/"/>
      <url>/2023/03/05/The%20application%20of%20the%20inheritance%20of%20interface%20and%20the%20inheritance%20of%20implementation/</url>
      
        <content type="html"><![CDATA[<h1 id="The-application-of-the-inheritance-of-interface-and-the-inheritance-of-implementation"><a href="#The-application-of-the-inheritance-of-interface-and-the-inheritance-of-implementation" class="headerlink" title="The application of the inheritance of interface and the inheritance of implementation"></a>The application of the inheritance of interface and the inheritance of implementation</h1><blockquote><p>Read the Effective C++ P161 for details</p></blockquote><h2 id="Pure-virtual"><a href="#Pure-virtual" class="headerlink" title="Pure virtual"></a>Pure virtual</h2><blockquote><p>The pure virtual function is armed at making sure derived classed only derive the interface</p></blockquote><p>we cannot give a definition to a function because it’s different in different Class. The pure virtual will be the first choice.</p><h2 id="impure-virtual"><a href="#impure-virtual" class="headerlink" title="impure virtual"></a>impure virtual</h2><p>this function cannot be changed and have a default function</p><h2 id="non-virtual"><a href="#non-virtual" class="headerlink" title="non-virtual"></a>non-virtual</h2><p>this function cannot not be changed. It’s a forced implementation </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++格式</title>
      <link href="/2023/03/05/c++%E6%A0%BC%E5%BC%8F/"/>
      <url>/2023/03/05/c++%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="C-cout成员方法格式化输出"><a href="#C-cout成员方法格式化输出" class="headerlink" title="C++ cout成员方法格式化输出"></a>C++ cout成员方法格式化输出</h2><p>《<a href="http://c.biancheng.net/view/7559.html">C++输入流和输出流</a>》一节中，已经针对 cout 讲解了一些常用成员方法的用法。除此之外，ostream 类中还包含一些可实现格式化输出的成员方法，这些成员方法都是从 ios 基类（以及 ios_base 类）中继承来的，cout（以及 cerr、clog）也能调用。</p><p>下面 罗列了 ostream 类中可实现格式化输出的常用成员方法，以及它们各自的用法。</p><table><thead><tr><th>成员函数</th><th>说明</th></tr></thead><tbody><tr><td>flags(fmtfl)</td><td>当前格式状态全部替换为 fmtfl。注意，fmtfl 可以表示一种格式，也可以表示多种格式。</td></tr><tr><td>precision(n)</td><td>设置输出浮点数的精度为 n。</td></tr><tr><td>width(w)</td><td>指定输出宽度为 w 个字符。</td></tr><tr><td>fill(c)</td><td>在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）。</td></tr><tr><td>setf(fmtfl, mask)</td><td>在当前格式的基础上，追加 fmtfl 格式，并删除 mask 格式。其中，mask 参数可以省略。</td></tr><tr><td>unsetf(mask)</td><td>在当前格式的基础上，删除 mask 格式。</td></tr></tbody></table><p>其中，对于表 1 中 flags() 函数的 fmtfl 参数、setf() 函数中的 fmtfl 参数和 mask 参数以及 unsetf() 函数 mask 参数，可以选择表 2 中列出的这些值。</p><table><thead><tr><th>标 志</th><th>作 用</th></tr></thead><tbody><tr><td>ios::boolapha</td><td>把 true 和 false 输出为字符串</td></tr><tr><td>ios::left</td><td>输出数据在本域宽范围内向左对齐</td></tr><tr><td>ios::right</td><td>输出数据在本域宽范围内向右对齐</td></tr><tr><td>ios::internal</td><td>数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充</td></tr><tr><td>ios::dec</td><td>设置整数的基数为 10</td></tr><tr><td>ios::oct</td><td>设置整数的基数为 8</td></tr><tr><td>ios::hex</td><td>设置整数的基数为 16</td></tr><tr><td>ios::showbase</td><td>强制输出整数的基数（八进制数以 0 开头，十六进制数以 0x 打头）</td></tr><tr><td>ios::showpoint</td><td>强制输出浮点数的小点和尾数 0</td></tr><tr><td>ios::uppercase</td><td>在以科学记数法格式 E 和以十六进制输出字母时以大写表示</td></tr><tr><td>ios::showpos</td><td>对正数显示“+”号</td></tr><tr><td>ios::scientific</td><td>浮点数以科学记数法格式输出</td></tr><tr><td>ios::fixed</td><td>浮点数以定点格式（小数形式）输出</td></tr><tr><td>ios::unitbuf</td><td>每次输出之后刷新所有的流</td></tr></tbody></table><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;    </span><br><span class="line">double a = 1.23;    //设定后续输出的浮点数的精度为 4 </span><br><span class="line">cout.precision(4);   </span><br><span class="line">cout &lt;&lt;&quot;precision: &quot;&lt;&lt; a &lt;&lt; endl;    //设定后续以科学计数法的方式输出浮点数   </span><br><span class="line">cout.setf(ios::scientific); </span><br><span class="line">cout &lt;&lt;&quot;scientific：&quot;&lt;&lt; a &lt;&lt; endl;  </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><p>precision: 1.23<br>scientific：1.2300e+00</p><blockquote><p>注意，当 cout 采用此方式进行格式化输出时，其后不能立即输出数据，而只能像示例程序中那样，再用一个 cout 输出数据。</p></blockquote><p>值得一提的是，当调用 unsetf() 或者 2 个参数的 setf() 函数时，为了提高编写代码的效率，可以给 mask 参数传递如下 3 个组合格式：</p><ul><li>ios::adjustfield：等价于 ios::left | ios::right | ios::internal；</li><li>ios::basefield：等价于 ios::dec | ios::oct | ios::hex；</li><li>ios::floatfield：等价于 ios::scientific | ios::fixed。</li></ul><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;using namespace std;int main()&#123;    double f = 123;    //设定后续以科学计数法表示浮点数    cout.setf(ios::scientific);    cout &lt;&lt; f &lt;&lt; &#x27;\n&#x27;;    //删除之前有关浮点表示的设定    cout.unsetf(ios::floatfield);    cout &lt;&lt; f;    return 0;&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><p>1.230000e+02<br>123</p><h2 id="使用流操纵算子格式化输出"><a href="#使用流操纵算子格式化输出" class="headerlink" title="使用流操纵算子格式化输出"></a>使用流操纵算子格式化输出</h2><p>表 3 罗列了 <iomanip> 头文件中定义的一些常用的格式控制符，它们都可用于格式化输出。</p><table><thead><tr><th>流操纵算子</th><th>作  用</th><th></th></tr></thead><tbody><tr><td>*dec</td><td>以十进制形式输出整数</td><td>常用</td></tr><tr><td>hex</td><td>以十六进制形式输出整数</td><td></td></tr><tr><td>oct</td><td>以八进制形式输出整数</td><td></td></tr><tr><td>fixed</td><td>以普通小数形式输出浮点数</td><td></td></tr><tr><td>scientific</td><td>以科学计数法形式输出浮点数</td><td></td></tr><tr><td>left</td><td>左对齐，即在宽度不足时将填充字符添加到右边</td><td></td></tr><tr><td>*right</td><td>右对齐，即在宽度不足时将填充字符添加到左边</td><td></td></tr><tr><td>setbase(b)</td><td>设置输出整数时的进制，b&#x3D;8、10 或 16</td><td></td></tr><tr><td>setw(w)</td><td>指定输出宽度为 w 个字符，或输入字符串时读入 w 个字符。注意，该函数所起的作用是一次性的，即只影响下一次 cout 输出。</td><td></td></tr><tr><td>setfill(c)</td><td>在指定输出宽度的情况下，输出的宽度不足时用字符 c 填充（默认情况是用空格填充）</td><td></td></tr><tr><td>setprecision(n)</td><td>设置输出浮点数的精度为 n。  在使用非 fixed 且非 scientific 方式输出的情况下，n 即为有效数字最多的位数，如果有效数字位数超过 n，则小数部分四舍五人，或自动变为科学计 数法输出并保留一共 n 位有效数字。  在使用 fixed 方式和 scientific 方式输出的情况下，n 是小数点后面应保留的位数。</td><td></td></tr><tr><td>setiosflags(mask)</td><td>在当前格式状态下，追加 mask 格式，mask 参数可选择表 2 中的所有值。</td><td></td></tr><tr><td>resetiosflags(mask)</td><td>在当前格式状态下，删除 mask 格式，mask 参数可选择表 2 中的所有值。</td><td></td></tr><tr><td>boolapha</td><td>把 true 和 false 输出为字符串</td><td>不常用</td></tr><tr><td>*noboolalpha</td><td>把 true 和 false 输出为 0、1</td><td></td></tr><tr><td>showbase</td><td>输出表示数值的进制的前缀</td><td></td></tr><tr><td>*noshowbase</td><td>不输出表示数值的进制.的前缀</td><td></td></tr><tr><td>showpoint</td><td>总是输出小数点</td><td></td></tr><tr><td>*noshowpoint</td><td>只有当小数部分存在时才显示小数点</td><td></td></tr><tr><td>showpos</td><td>在非负数值中显示 +</td><td></td></tr><tr><td>*noshowpos</td><td>在非负数值中不显示 +</td><td></td></tr><tr><td>uppercase</td><td>十六进制数中使用 A~E。若输出前缀，则前缀输出 0X，科学计数法中输出 E</td><td></td></tr><tr><td>*nouppercase</td><td>十六进制数中使用 a~e。若输出前缀，则前缀输出 0x，科学计数法中输出 e。</td><td></td></tr><tr><td>internal</td><td>数值的符号（正负号）在指定宽度内左对齐，数值右对 齐，中间由填充字符填充。</td><td></td></tr></tbody></table><blockquote><p>注意：“流操纵算子”一栏带有星号 * 的格式控制符，默认情况下就会使用。例如在默认情况下，整数是用十进制形式输出的，等效于使用了 dec 格式控制符。</p></blockquote><p>和 cout 成员方法的用法不同，下面程序演示了表 3 中这些格式控制符的用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;    //以十六进制输出整数   </span><br><span class="line">cout &lt;&lt; hex &lt;&lt; 16 &lt;&lt; endl;  //删除之前设定的进制格式，以默认的 10 进制输出整数 </span><br><span class="line">cout &lt;&lt; resetiosflags(ios::basefield)&lt;&lt; 16 &lt;&lt; endl;  </span><br><span class="line">double a = 123;    //以科学计数法的方式输出浮点数  </span><br><span class="line">cout &lt;&lt; scientific &lt;&lt; a &lt;&lt; endl;    //删除之前设定的科学计数法的方法  </span><br><span class="line">cout &lt;&lt; resetiosflags(ios::scientific) &lt;&lt; a &lt;&lt; endl; </span><br><span class="line">return 0;&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><p>10<br>16<br>1.230000e+02<br>123</p><blockquote><p>注意，如果两个相互矛盾的标志同时被设置，如先设置 setiosflags(ios::fixed)，然后又设置 setiosflags(ios::scientific)，那么结果可能就是两个标志都不起作用。因此，在设置了某标志，又要设置其他与之矛盾的标志时，就应该用 resetiosflags 清除原先的标志。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>实验要用的知识点</title>
      <link href="/2023/03/05/%E5%AE%9E%E9%AA%8C%E8%A6%81%E7%94%A8%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/03/05/%E5%AE%9E%E9%AA%8C%E8%A6%81%E7%94%A8%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h2><h3 id="配置的命令格式"><a href="#配置的命令格式" class="headerlink" title="配置的命令格式"></a>配置的命令格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Router(config)#router rip</span><br><span class="line">Router(config-router)#network &lt;network-number&gt; #属于上面的网络都运行RIP路由协议</span><br></pre></td></tr></table></figure><h3 id="基本知识点"><a href="#基本知识点" class="headerlink" title="基本知识点"></a>基本知识点</h3><ol><li>RIP 是一种距离向量协议，它以预定间隔将其整个路由表广播到每个邻居路由器。默认间隔为<strong>30秒</strong>。</li><li>RIP使用<strong>跳数</strong>作为度量标准，最大跳数为<strong>15</strong>，达到16跳的报文自动抛弃。、</li><li>RIP v1能够在多达六个等价路径上进行**负载平衡(Load Balancing)**，默认情况下为四个路径，最多6个，跳数相同才能完成负载均衡，跳数不同不满足条件、</li><li>它不会在其更新中发送子网掩码信息:意味着必须用同样的子网掩码，不支持VLSM或无类域间路由(CIDR，Classless Interdomain Routing)。</li><li>它以255.255.255.255的广播形式发送更新:只能发给邻居，不能通过路由器转发。</li><li>它不支持身份验证(authentication):只要启动RIP就可以接受到信息，也就意味着只要接入网络并且启动RIP进程，就可以了解到整个网络拓扑</li></ol><h3 id="RIP的更新规则"><a href="#RIP的更新规则" class="headerlink" title="RIP的更新规则"></a>RIP的更新规则</h3><ol><li>把发来的路由表的下一跳都改为发来的路由器编号，距离都加1</li><li>如果原来的路由表没有目的网络，更新<br>如果原来的路由表有下一跳和目的网络一样的，不管距离大小，都更新<br>如果原来的路由表，有相同目的网络的但是下一跳不一样，保留距离小的。<br>没有的物理表，保持原样</li></ol><p>路由表ex：</p><table><thead><tr><th>目的网络</th><th>距离</th><th>下一跳路由器</th></tr></thead></table><h2 id="VLAN和Trunk"><a href="#VLAN和Trunk" class="headerlink" title="VLAN和Trunk"></a>VLAN和Trunk</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>骨干（backbone&#x2F;trunk link）：交换设备和交换设备之间所使用的连接（不然有几个 VLAN 就需要几条线，浪费端<br>口）</p><p>（1）Access Links（接入链路）：<br>接入链路是在交换机上只属于一个 VLAN 的链路，任何接入的设备并不知情有 VLAN 的存在（VLAN 对每台设备<br>是透明的）<br>（2）Trunk VLANS（中继链路）：<br>点对点，支持多个 VLANs；主要用来连接交换机和交换机；不需要属于某个特定的 VLAN；可能有一个本地 VLAN；<br>支持在快速以太网和 G 比特以太网；节省端口</p><h3 id="配置的命令格式-1"><a href="#配置的命令格式-1" class="headerlink" title="配置的命令格式"></a>配置的命令格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int f0/2</span><br><span class="line">switchport mode access</span><br><span class="line">switchport access vlan 2</span><br><span class="line">int f0/3</span><br><span class="line">switchport mode trunk</span><br></pre></td></tr></table></figure><h2 id="静态NAT"><a href="#静态NAT" class="headerlink" title="静态NAT"></a>静态NAT</h2><p>​1、指定NAT内部接口&#96;</p><p>​         在内网相应接口的接口配置模式下执行：<code>ip nat inside</code></p><p>​2、指定NAT外部接口&#96;</p><p>​         在外网相应接口的接口配置模式下执行：<code>ip nat outside</code></p><p>​3、在内部本地地址与内部全局地址之间建立静态地址转换关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip nat inside source static 内部本地地址 内部全局地址</span><br></pre></td></tr></table></figure><p>​    4、(实际上用第三条就可以了)在外部全局地址与外部本地地址之间建立静态地址转换关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip nat outside source static 外部全局地址 外部本地地址</span><br></pre></td></tr></table></figure><ol start="5"><li><code>show ip nat translations</code>   展示配置的情况</li></ol><h2 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p><code>Router(config)#access-list &lt;access-list-number&gt; &lt;permit/deny&gt; &lt;test-conditions&gt;</code></p><p><code>&lt;test-conditions&gt;</code>参数是IP掩码和通配符掩码</p><p><code>show access-list</code>展示ACL配置</p><p><code>&lt;protocol&gt; access-group access-list-number &lt;in/out&gt;</code></p><p>IP掩码：Ipv4地址</p><p>通配符掩码：</p><ul><li><p><strong>0位表示检查该位位置</strong></p></li><li><p><strong>1表示忽略该位位置</strong></p></li></ul><h3 id="扩展ACL"><a href="#扩展ACL" class="headerlink" title="扩展ACL"></a>扩展ACL</h3><p>扩展ACL的编号范围为100-199，并”扩展”了标准ACL的功能。</p><p>可以基于目的地址，<strong>ip协议的部分(更加细分):您可以编写语句以仅拒绝”ICMP”等协议或”RIP”和”IGRP”之类的路由协议</strong>，协议套件的上层（TFTP”或”HTTP”之类的协议，eq，gt，lt和neq(等于，大于，小于和不等于)之类的操作数来指定如何处理特定协议）</p><ul><li>由于扩展的ACL具有目标信息，因此<strong>您希望将其放置在尽可能靠近源的位置。</strong></li></ul><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><p>在<a href="https://so.csdn.net/so/search?q=%E8%B7%AF%E7%94%B1%E5%99%A8&spm=1001.2101.3001.7020">路由器</a>上读取第三层及第四层包头中的信息如源地址，目的地址，源端口，目的端口等，根据预先定 义好的规则对包进行过滤，从而达到访问控制的目的。</p><p>类型：</p><p>标准访问控制列表：一般应用在out出站接口。建议配置在离目标端最近的路由上</p><p>扩展访问控制列表：配置在离源端最近的路由上，一般应用在入站in方向</p><p>命名访问控制列表：允许在标准和扩展访问列表中使用名称代替表号</p><p>准则：</p><ul><li><p>按照顺序对ACL语句进行测试</p></li><li><p>ACL末尾有一个隐含的”deny any”语句:如果数据包与ACL中的任何语句都不匹配，则将其丢弃。</p></li></ul><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20230103234438456.png" alt="image-20230103234438456"></p><p><strong>ICMP（Internet Control Message Protocol）网际控制报文协议</strong></p><p>允许主机或路由器报告差错情况和提供有关异常情况的报告，为了更有效的转发ip数据报和提高交付成功的机会。</p><p>包括ICMP差错报告报文、ICMP询问报文。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>样本统计,极大似然估计，矩估计，无偏性</title>
      <link href="/2023/03/05/%E6%A0%B7%E6%9C%AC%E7%BB%9F%E8%AE%A1,%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%EF%BC%8C%E7%9F%A9%E4%BC%B0%E8%AE%A1%EF%BC%8C%E6%97%A0%E5%81%8F%E6%80%A7/"/>
      <url>/2023/03/05/%E6%A0%B7%E6%9C%AC%E7%BB%9F%E8%AE%A1,%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%EF%BC%8C%E7%9F%A9%E4%BC%B0%E8%AE%A1%EF%BC%8C%E6%97%A0%E5%81%8F%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/IMG_20221129_145754.jpg" alt="IMG_20221129_145754"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/IMG_20221129_151215.jpg" alt="IMG_20221129_151215"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221129154500798.png" alt="image-20221129154500798"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221129154515316.png" alt="image-20221129154515316"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>假设检验</title>
      <link href="/2023/03/05/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"/>
      <url>/2023/03/05/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=690427890&bvid=BV1624y117o6&cid=900595312&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>基本概念</p><p>检验均值</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20230125155909795.png" alt="image-20230125155909795"></p><p>原假设H0备选假设H1</p><p>拒绝域</p><p>计算统计量，拒绝域,接受域，原假设，备择假设</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20230125160708915.png" alt="image-20230125160708915"></p><p>计算统计量查看拒绝域</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cache的一部分讲解</title>
      <link href="/2023/03/05/Cache%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%E8%AE%B2%E8%A7%A3/"/>
      <url>/2023/03/05/Cache%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Cacha"><a href="#Cacha" class="headerlink" title="Cacha"></a>Cacha</h1><p>Cache主要是为了解决内存墙带来的CPU和主存协作问题</p><h3 id="程序访问的局部性"><a href="#程序访问的局部性" class="headerlink" title="程序访问的局部性"></a>程序访问的局部性</h3><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211031713220.png" alt="image-20221103171316185"></p><h3 id="平均访问时间"><a href="#平均访问时间" class="headerlink" title="平均访问时间"></a>平均访问时间</h3><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211031713718.png" alt="image-20221103171347687"></p><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211031716762.png" alt="image-20221103171611723">、</p><p>M是块数，C是行数</p><p>上面定义了Cacha直接映射时候的地址的结构，有C行所有logC的值是Cacha的行号和块内的地址。</p><p>然后一次存储单元是8个字，所有有16个单元就是说，寻址能力是4，所有前2位是用来区分映射到不同行的不同的块</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211031716043.png" alt="image-20221103171619997"></p><p>通过cache字块的地址来找到对应的行，如果标记一样就命中。</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211031716235.png" alt="image-20221103171629191"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211031716548.png"></p><p>优点；</p><ul><li>简单</li><li>快速映射</li><li>快速检查</li></ul><p>缺点</p><ul><li>抖动现象：如果程序需要重复访问两个来自同一行不同块的字，需要不断的交换cache中，cache的命中率将会降低，</li></ul><p>适用于大容量的cache</p><ul><li>行数变多，发生冲突失效的概率降低</li><li>硬件电路简单，增大容量对Tc的影响不明显</li></ul><h3 id="关联映射"><a href="#关联映射" class="headerlink" title="关联映射"></a>关联映射</h3><p>一主存块可以装入cache的任意一行</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211031637483.png" alt="image-20221103163757442"></p><p>取消行的编号，直接储存块的编号</p><p>优点</p><p>避免抖动</p><p>缺点</p><ul><li>实现起来比较复杂</li><li>cache搜索代价大，检测时候要访问cache的每一行</li></ul><p>适合小容量cache</p><ul><li>cache更容易产生抖动</li><li>cache的搜素时间短</li></ul><h3 id="组关联映射"><a href="#组关联映射" class="headerlink" title="组关联映射"></a>组关联映射</h3><p>K-路组映射</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211031639665.png" alt="image-20221103163949633"></p><p>k，一组中有k行</p><p>主存的块可以被映射到固定组的任意一行</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211031643520.png" alt="image-20221103164332474"></p><h2 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h2><p>替换算法通过硬件来实现，设计替换算法的目的是提高命中率</p><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211031656547.png" alt="image-20221103165625492"></p><p>标记最近使用的元素：</p><p>当一个元素使用的时候，自己1，傍边的0（表示自己比傍边的经常访问)</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211031708270.jpeg" alt="IMG_20221103_170753"></p><p>简单点，使用了就归0，其他的加1，如果要加入新的，就把数最大的给踢了，加入最新的。</p><p>需要的位数，对于每一组，要k个logk来做标记</p><p>LRU的提高效果没有那么高</p><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211031719984.png" alt="image-20221103171924946"></p><h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211031723263.png" alt="image-20221103172322225"></p><h3 id="随机替换算法"><a href="#随机替换算法" class="headerlink" title="随机替换算法"></a>随机替换算法</h3><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211031724694.png" alt="image-20221103172449656"></p><h2 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h2><h3 id="写直达"><a href="#写直达" class="headerlink" title="写直达"></a>写直达</h3><p>所有写操作都同时对cache和主存进行</p><p>优点</p><p>确保主存中的数据总是和cache中的数据一致，总是最新的（例如多CPU 同步的场景）</p><p>缺点</p><p>产生大量的主存访问，减慢写操作</p><h3 id="写回法"><a href="#写回法" class="headerlink" title="写回法"></a>写回法</h3><p>优点</p><ul><li>减少了访问主存的次数</li></ul><p>缺点</p><ul><li>部分主存的数据可能不是最新的<ul><li>I&#x2F;O模块存取时可能无法获得最新的数据，为解决该问题会使得电 路设计更加复杂且有可能带来性能瓶颈</li></ul></li></ul><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211031743483.png" alt="image-20221103174308449"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211031743879.png" alt="image-20221103174351848"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211031746026.png" alt="image-20221103174618992"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20230131205534052.png" alt="image-20230131205534052"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>硬磁盘存储器的计算题</title>
      <link href="/2023/03/05/%E7%A1%AC%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E8%AE%A1%E7%AE%97%E9%A2%98/"/>
      <url>/2023/03/05/%E7%A1%AC%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E8%AE%A1%E7%AE%97%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="硬磁盘存储器访问时间"><a href="#硬磁盘存储器访问时间" class="headerlink" title="硬磁盘存储器访问时间"></a>硬磁盘存储器访问时间</h1><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><h3 id="寻道时间"><a href="#寻道时间" class="headerlink" title="寻道时间"></a>寻道时间</h3><p>磁头定位到磁道的时间</p><h3 id="旋转延迟"><a href="#旋转延迟" class="headerlink" title="旋转延迟"></a>旋转延迟</h3><p>等待相应扇区的起始位置移动带磁头，通常是旋转半圈的时间</p><h3 id="传送时间"><a href="#传送时间" class="headerlink" title="传送时间"></a>传送时间</h3><p>传输数据的时间（也就是磁头在有数据的部分都移动一遍）</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221204230119632.png" alt="image-20221204230119632"></p><p>平均访问时间&#x3D;平均寻道时间+平均旋转延迟+传送时间</p><p>相邻磁道，每个磁道都要考虑旋转延迟，只要考虑第一个磁道的寻道时间（题目给了具体寻道时间的话就要全部给出）。</p><h3 id="存取情况（顺序存取）"><a href="#存取情况（顺序存取）" class="headerlink" title="存取情况（顺序存取）"></a>存取情况（顺序存取）</h3><h3 id="存取在相邻的磁道"><a href="#存取在相邻的磁道" class="headerlink" title="存取在相邻的磁道"></a>存取在相邻的磁道</h3><p>寻道时间只算一次，旋转延迟取转半圈的时间。传送时间正常求</p><p>寻道时间+旋转延迟*磁道数+所有的传送时间</p><h3 id="随机存取"><a href="#随机存取" class="headerlink" title="随机存取"></a>随机存取</h3><p>每读取一个扇区就要寻道和旋转延迟</p><p>扇区数*（寻道时间+旋转延迟+一个扇区的传送时间）</p><h1 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h1><h3 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h3><p>按照请求访问磁盘的先后次序进行处理</p><p>优点：公平简单 </p><p>缺点：如果有大量访问磁盘的任务，且请求访问的磁道很分散，则性 能上很差，寻道时间长</p><p>具体计算：按照请求顺序，看移动的磁道（移动就是单纯的相减）</p><h2 id="扇区传送时间可以用数据传输速度来代替（数据传输率，不只考虑纯读取时候的时间）"><a href="#扇区传送时间可以用数据传输速度来代替（数据传输率，不只考虑纯读取时候的时间）" class="headerlink" title="扇区传送时间可以用数据传输速度来代替（数据传输率，不只考虑纯读取时候的时间）"></a>扇区传送时间可以用数据传输速度来代替（数据传输率，不只考虑纯读取时候的时间）</h2><h3 id="最短寻道时间优先（SSTF）"><a href="#最短寻道时间优先（SSTF）" class="headerlink" title="最短寻道时间优先（SSTF）"></a>最短寻道时间优先（SSTF）</h3><p>优先处理起始位置与当前磁头位置最接近的读写任务</p><p>优点：每次的寻道时间最短（局部最优），平均寻道时间缩短</p><p>缺点：可能产生饥饿现象，尤其是位于两端的磁道请求</p><p>具体计算：找最近的之后再去移动</p><h3 id="扫描-x2F-电梯（SCAN）"><a href="#扫描-x2F-电梯（SCAN）" class="headerlink" title="扫描&#x2F;电梯（SCAN）"></a>扫描&#x2F;电梯（SCAN）</h3><p>总是按照一个方向进行磁盘调度，直到该方向上的边缘，然后改变方向</p><p>优点：性能好，寻道时间短，不会有产生饥饿现象</p><p>缺点：总是按照一个方向进行磁盘调度，直到该方向上的边缘，然后改变方向</p><p>具体计算：先朝一个方向到头然后朝另一个方向到头，</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221204232254912.png" alt="image-20221204232254912"></p><p>可以画数轴计算</p><h3 id="循环扫描（S-SCAN）"><a href="#循环扫描（S-SCAN）" class="headerlink" title="循环扫描（S-SCAN）"></a>循环扫描（S-SCAN）</h3><p>和上面相同，不过方向不会改变</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221204232357380.png" alt="image-20221204232357380"></p><h3 id="C-LOOK"><a href="#C-LOOK" class="headerlink" title="C-LOOK"></a>C-LOOK</h3><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221204232604342.png" alt="image-20221204232604342"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树的应用</title>
      <link href="/2023/03/05/%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2023/03/05/%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BinaryNode <span class="title function_">find</span><span class="params">(Conparable x,BinaryNode t)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="literal">null</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">if</span>(x.compareTo(t.element)&lt;<span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> find(x,t.left);</span><br><span class="line"> <span class="keyword">if</span>(x.comparaTo(t.element)&gt;<span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> find(x,t.rigth);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="keyword">return</span> t;</span><br><span class="line">&#125;<span class="comment">//复杂度是数的高度，搜索次数是对数量级的。</span></span><br></pre></td></tr></table></figure><p>二叉搜索数的节点是不可以重复的。<br>二叉搜索树的插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(t==<span class="literal">null</span>)</span><br><span class="line">t=<span class="keyword">new</span> <span class="title class_">BinaryNode</span>(x,<span class="literal">null</span>,<span class="literal">null</span>);<span class="comment">//找找，找到头</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x.compareTo(t.element)&lt;<span class="number">0</span>)</span><br><span class="line">t.left=insert(x.t.left);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x.comparaTo(t.element)&gt;<span class="number">0</span>)</span><br><span class="line">t.right=insert(x.t.right);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">;</span><br><span class="line"><span class="keyword">return</span> t；<span class="comment">//这种方式的插入不是太好，要保证二叉搜索树是一个比较接近满二叉搜索树的</span></span><br></pre></td></tr></table></figure><p>二叉搜素树的删除</p><p><img src="http://pic.mikumifa.cn/2022/11/02/c741b895ab658.png"></p><p>删除的3种情况</p><p>删除树叶直接删</p><p>有一个子树的直接接上去，</p><p>有2个子树的，把左子树的最大的节点（左子树，然后一直朝右走）</p><p><img src="http://pic.mikumifa.cn/2022/11/02/e32a91742e8a8.png"></p><p>树的遍历的时候在递归的开头设下边界限制，那么后面就不需要单独判断是还不是null</p><p>复杂度是数的高度，先找，找到之后，3种情况</p><ol><li>都有节点，就把右子树最小的（或者做子树最大的值放上去，然后递归的调用删除element 的情况（实际上就是把最小的给删掉就可以了））</li></ol><p>2，如果不是null，直接接到下一个节点就可以了，（找最小值的方法可以直接的找最右边或者最左边）</p><h2 id="AVL-Tree"><a href="#AVL-Tree" class="headerlink" title="AVL Tree"></a>AVL Tree</h2><p>每一个子树的左子树和友子树的高度差1</p><p><strong>平衡因子（</strong>bf）：结点的左子树的深度减去右子树的深度。<br>即： <strong>结点的平衡因子 &#x3D; 左子树的高度 - 右子树的高度</strong> 。</p><p>一个节点有一个缓存</p><p>有n个元素，他的树的高度是logn，查找的复杂度是log2n</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211041731428.png" alt="image-20221104172737286"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果是null就插入（插入在末尾）</span><br><span class="line">每次insert之后看一下左右高度有没有问题，并且更新自身高度(递归结束后才判断就很秒)</span><br><span class="line">如果高度有问题，就看是左旋还是右旋</span><br></pre></td></tr></table></figure><p>几种情况</p><ol><li>右子树的右子树</li></ol><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211041417706.png" alt="image-20221104141728646"></p><p>左旋操作，右子树的左节点和原来的头节点结合，原来的右子树的和原来的头结点结合</p><p>2.右子树的左子树（内侧）</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211041418059.png" alt="image-20221104141842012"></p><p>RL可以理解成3个节点区中间节点是根节点·</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221104193801138.png" alt="image-20221104193801138"></p><p>左旋和右旋转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(node.left) &lt; 0) &#123;</span><br><span class="line">       node.left = leftRotate(node.left);</span><br><span class="line">       return rightRotate(node);</span><br><span class="line">   &#125;//先做旋转变成普通情况然后再右旋转</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/xiaojin21cen/article/details/97602146">数据结构 —— 图解AVL树(平衡二叉树)</a></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211041428262.png" alt="image-20221104142832211"></p><p>左单旋转代码</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211041459545.png" alt="image-20221104145933507"></p><p>AVL的删除，</p><p>首先同样的，攒删除的代码后面加上判断时候要左旋和右旋转，并且要更新高度</p><p>删除的方法是替换成后继，然后递归的删除后继。</p><h2 id="B-TREES"><a href="#B-TREES" class="headerlink" title="B-TREES"></a>B-TREES</h2><p>m路搜索树。有m-1个k值</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image%2F202211041518169.png" alt="image-20221104151859131"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221104175307044.png" alt="image-20221104175307044"></p><p>m路子树最多m-1个k值</p><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>如果一层没有满，就在那一层插入，否则下一层</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221104175719414.png" alt="image-20221104175719414"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221104175740381.png" alt="image-20221104175740381"></p><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>1，删除后没有任何影响</p><p>上图的50,84</p><p>2 ，删除后者一层没有了，把上一次最大或者最小的提上去</p><h2 id="下平衡的二叉树"><a href="#下平衡的二叉树" class="headerlink" title="下平衡的二叉树"></a>下平衡的二叉树</h2><p>跟节点至少2个，中间节点至少m&#x2F;2（向上取整）</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221104180636876.png" alt="image-20221104180636876"></p><h2 id="高度和节点数"><a href="#高度和节点数" class="headerlink" title="高度和节点数"></a>高度和节点数</h2><p>h最多有h个节点，最多有(m^h-1)(m-1)个结点，从1开始技计数，每层是h-1</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221104181025950.png" alt="image-20221104181025950"></p><p>在二阶B树中，每一个内部节点都有至少2个子女，并且所有的外部节点都必须在同一级上，所以2阶B树是满阶二叉树</p><p>在三阶B树中(通常被我们叫做2-3树)，每一个内部节点有2个或者3个子女</p><h3 id="B树的性质"><a href="#B树的性质" class="headerlink" title="B树的性质"></a>B树的性质</h3><p>外部节点的层数相同，外部节点的个数是关键字+1，外部节点的个数是总共的k值加1.</p><h3 id="B树的搜索算法。"><a href="#B树的搜索算法。" class="headerlink" title="B树的搜索算法。"></a>B树的搜索算法。</h3><p>对于高度为h的B树，访问磁盘的次数最多为h次</p><h2 id="B数的插入算法"><a href="#B数的插入算法" class="headerlink" title="B数的插入算法"></a>B数的插入算法</h2><blockquote><p>关键点，key的多少，</p><p>关键字总是插在最后面</p><p><a href="https://www.bilibili.com/video/BV1Jh411q7xP">B-树的插入</a></p></blockquote><ol><li>做插入的时候优先插入叶节点:<ul><li>如果叶节点还没有满的时候，直接插入即可</li><li>如果叶节点已经满了的时候，会进行分类，将中间节点的一个值拉到上级结点(这个结点在中间，并入跟节点)。</li><li><a href="https://zhuanlan.zhihu.com/p/130698465">B树和B+树的插入、删除图文详解 - 知乎 (zhihu.com)</a></li><li><a href="https://www.bilibili.com/video/BV11h411W74p">https://www.bilibili.com/video/BV11h411W74p</a></li></ul></li></ol><h2 id="B树的删除算法"><a href="#B树的删除算法" class="headerlink" title="B树的删除算法"></a>B树的删除算法</h2><p>首先判断删除的关键码是否都在B树中，不在的话直接退出。</p><p><a href="https://zhuanlan.zhihu.com/p/130698465">B树和B+树的插入、删除图文详解 - 知乎 (zhihu.com)</a></p><p><a href="https://www.bilibili.com/video/BV11h411W74p">https://www.bilibili.com/video/BV11h411W74p</a></p><ol><li><p>叶节点</p><ol><li><p>如果超过m&#x2F;2向上取整的关键码。直接删除</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221104183611625.png" alt="image-20221104183611625"></p></li><li><p>如果不够，邻居富有的解邻居(设计根的操作，347-》353-》367平移)</p></li><li><p>如果不够，和父亲借，然后和邻居合并（把根拖下去合并）</p></li><li><p>如果父亲借了之后就没了，就让直接合并</p></li></ol></li></ol><p>2.如果删除的是非叶节点</p><p>把这个节点替换成最小的或者最大的关键码。</p><p>递归调用下面的(递归成删除叶子节点)</p><h2 id="B-tree的定义"><a href="#B-tree的定义" class="headerlink" title="B+ tree的定义"></a>B+ tree的定义</h2><ol><li>树中每个非叶结点最多有m棵子树</li><li>根结点(非叶结点)至少有2棵子树</li><li>除根结点外，每个非叶结点至少有(m&#x2F;2)(向上取整)棵子树；有n棵子树的非叶结点有n-1个关键码</li><li>所有叶结点都处于同一层次上，包含了全部关键码及指向相应数据对象存放地址，关键码按关键码从小到大顺序链接</li><li>每个叶结点中子树棵树n可以＞m，也可以＜m。 假设叶结点可容纳的最大关键码数为m1，则指向对象的指针数也有m1，这时子树棵数n应满足((m1&#x2F;2)(向上取整)，m1)</li><li>根结点本身又是叶结点，则结点格式同叶结点</li></ol><h2 id="B-tree的特点"><a href="#B-tree的特点" class="headerlink" title="B+ tree的特点"></a>B+ tree的特点</h2><ol><li>有两个头指针</li><li>一个指向B+树的根结点，可以进行自顶向下的随机搜索</li><li>一个指向关键码最小的叶结点，进行顺序搜索；</li><li>保证树过深，用来进行平衡</li></ol><h2 id="B-tree的运算"><a href="#B-tree的运算" class="headerlink" title="B+ tree的运算"></a>B+ tree的运算</h2><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221104194318667.png" alt="image-20221104194318667"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221104194405770.png" alt="image-20221104194405770"></p><h2 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h2><p>基本上同B树，所不同的是一直查到叶结点上的这个关键码为止</p><h2 id="插入算法"><a href="#插入算法" class="headerlink" title="插入算法"></a>插入算法</h2><ol><li>仅在叶结点上进行。每插入一关键码，判别子树棵树＞m1，如果大于，则将该结点分裂：((m1+1)&#x2F;2)(向上取整)，((m1+1)&#x2F;2)(向上取整)</li><li>问题变为传递到索引结点上可能的分裂，这时上限以m来确定(同B-树)</li></ol><h2 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法"></a>删除算法</h2><ol><li>在叶结点上删除一个关键码后要保证结点中的子树棵数仍然不小 于(m1&#x2F;2)(向上取整).</li><li>删除操作与B树类似，但上层索引中的关键码可保留，作为引导搜索的”分界关键码”的作用.</li></ol><h2 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h2><p><a href="https://www.bilibili.com/video/BV1rB4y1Q7e6">https://www.bilibili.com/video/BV1rB4y1Q7e6</a></p><p><strong><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221104185518500.png" alt="image-20221104185518500"></strong></p><ul><li><p>每个节点最大m个孩子节点</p></li><li><p>每一个节点的结构（p是指向孩子节点的额，n是个数，k是关键字）</p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221104185611290.png" alt="image-20221104185611290"></p></li><li><p>除根节点外，其他节点至少[m&#x2F;2]个孩子节点(向上取整)</p></li><li><p>若根节点不是叶子节点，根节点至少2个孩子节点</p></li><li><p>平衡节点为0，叶子节点在同一层</p></li></ul><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221104190444874.png" alt="image-20221104190444874"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bool isTree(Graph &amp;G)&#123;</span><br><span class="line">for(int i=1;i&lt;=G.vexnum;i++)&#123;</span><br><span class="line">visited[i]=FALSE;</span><br><span class="line">&#125;</span><br><span class="line">int Vnum=0,Enum=0;</span><br><span class="line">DFS(G,1,Vnum,Enum,visited);</span><br><span class="line">if(Vnum==G.vexnum&amp;&amp;Enum==2*(G.vexnum-1))&#123;//无向图，边数应为结点数-1的2倍 </span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">else return false;</span><br><span class="line">&#125; </span><br><span class="line">void DFS(Graph &amp;G,int v,int&amp; Vnum,int&amp; Enum,int visted[])&#123;</span><br><span class="line">visited[v]=TRUE;</span><br><span class="line">Vnum++;</span><br><span class="line">int w=FirstNeighbor(G,v);</span><br><span class="line">while(w!=1)&#123;</span><br><span class="line">Enum++;</span><br><span class="line">if(!visited[w])&#123;</span><br><span class="line">DFS(G,w,Vnum,Enum,visited);</span><br><span class="line">&#125;</span><br><span class="line">w=NextNeighbor(G,v,w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断无向图是否是一颗树</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>置信区间</title>
      <link href="/2023/03/05/%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4/"/>
      <url>/2023/03/05/%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="0置信区间的题目"><a href="#0置信区间的题目" class="headerlink" title=".0置信区间的题目"></a>.0置信区间的题目</h2><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/IMG_20221129_141105.jpg" alt="IMG_20221129_141105"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/IMG_20221129_141110.jpg" alt="IMG_20221129_141110"><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221129144308517.png" alt="image-20221129144308517"></p><p>000000000000000000000000000000000000000000000<img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/image-20221129144214659.png" alt="image-20221129144214659"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>概率论期中复习</title>
      <link href="/2023/03/05/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/03/05/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/IMG_20221105_110218.jpg" alt="IMG_20221105_110218"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/IMG_20221105_110223.jpg" alt="IMG_20221105_110223"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/IMG_20221105_110250.jpg" alt="IMG_20221105_110250"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/IMG_20221105_110254.jpg" alt="IMG_20221105_110254"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/IMG_20221105_110304.jpg" alt="IMG_20221105_110304"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/IMG_20221105_110308.jpg" alt="IMG_20221105_110308"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/IMG_20221105_110314.jpg" alt="IMG_20221105_110314"></p><p><img src="https://blog-1314638240.cos.ap-nanjing.myqcloud.com/image/IMG_20221105_110318.jpg" alt="IMG_20221105_110318">                                              </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>article title</title>
      <link href="/2023/03/05/article-title-1/"/>
      <url>/2023/03/05/article-title-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>article title</title>
      <link href="/2023/03/05/article-title/"/>
      <url>/2023/03/05/article-title/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/05/hello-world/"/>
      <url>/2023/03/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
